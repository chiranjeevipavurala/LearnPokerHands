<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poker Hand Evaluator - Learning Game</title>
    
    <!-- Google Analytics (replace GA_MEASUREMENT_ID with your actual ID) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-VPB1FJ0L5S"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-VPB1FJ0L5S');
    </script>

    
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a472a, #2d5a3d);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .header h1 {
            margin: 0 0 15px 0;
            font-size: 2.5em;
            font-weight: 300;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }
        
        .header p {
            margin: 0;
            font-size: 1.2em;
            opacity: 0.9;
            text-shadow: 0 1px 5px rgba(0,0,0,0.3);
        }
        
        /* Instructions Button */
        .instructions-btn {
            margin-top: 20px;
            padding: 12px 24px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .instructions-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            background: linear-gradient(135deg, #2980b9, #1f5f8b);
        }
        
        /* Instructions Panel */
        .instructions-panel {
            margin-top: 20px;
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 0;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.3);
            backdrop-filter: blur(10px);
            max-height: 0;
            transition: all 0.4s ease;
        }
        
        .instructions-panel.show {
            max-height: 80vh;
            padding: 25px;
            overflow-y: auto;
        }
        
        .instructions-content {
            color: #333;
            max-height: 70vh;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #888 #f1f1f1;
        }
        
        .instructions-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .instructions-content::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        .instructions-content::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        
        .instructions-content::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        .instructions-content h3 {
            margin: 0 0 20px 0;
            color: #2c3e50;
            font-size: 1.8em;
            text-align: center;
        }
        
        .instructions-content h4 {
            margin: 25px 0 10px 0;
            color: #34495e;
            font-size: 1.3em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }
        
        .instructions-content p {
            margin: 10px 0;
            line-height: 1.6;
            color: #555;
        }
        
        .instructions-content ol, .instructions-content ul {
            margin: 15px 0;
            padding-left: 25px;
        }
        
        .instructions-content li {
            margin: 8px 0;
            line-height: 1.5;
            color: #555;
        }
        
        .instructions-content strong {
            color: #2c3e50;
        }
        
        /* Close Button */
        .close-instructions-btn {
            display: block;
            margin: 25px auto 0 auto;
            padding: 10px 20px;
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .close-instructions-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 40px;
            flex-wrap: wrap;
            padding: 25px;
            background: rgba(255,255,255,0.08);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .control-group label {
            color: white;
            font-weight: 500;
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        select {
            padding: 12px 18px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            background: rgba(255,255,255,0.9);
            color: #333;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        select:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        select:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.5);
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            transition: all 0.3s ease;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        button:hover::before {
            left: 100%;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
            background: linear-gradient(135deg, #45a049, #4CAF50);
        }
        
        button:active {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        button:disabled {
            background: linear-gradient(135deg, #666, #555);
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        #resetBtn {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
        }
        
        #resetBtn:hover {
            background: linear-gradient(135deg, #c0392b, #e74c3c);
            box-shadow: 0 8px 25px rgba(231, 76, 60, 0.5);
        }
        
        .game-area {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
        
        .community-cards {
            text-align: center;
            background: rgba(255,255,255,0.1);
            padding: 30px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .community-cards h3 {
            margin: 0 0 20px 0;
            color: #f39c12;
            font-size: 1.5em;
            text-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        .community-cards > div {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .card {
            display: inline-block;
            width: 65px;
            height: 85px;
            background: linear-gradient(135deg, #fff, #f8f9fa);
            color: #333;
            border-radius: 12px;
            margin: 0 8px;
            text-align: center;
            line-height: 85px;
            font-weight: bold;
            font-size: 18px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3), 0 2px 4px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            border: 1px solid rgba(0,0,0,0.1);
        }
        
        .card:hover {
            transform: translateY(-8px) scale(1.05);
            box-shadow: 0 12px 30px rgba(0,0,0,0.4), 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .card.hidden {
            background: url('images/pokercardbackside.png') center/contain;
            background-repeat: no-repeat;
            color: transparent;
            border: 1px solid rgba(255,255,255,0.1);
            line-height: normal;
            border-radius: 12px;
            overflow: hidden;
            background-color: #2c3e50;
        }
        
        .card.hidden:hover {
            transform: translateY(-8px) scale(1.05);
            box-shadow: 0 12px 30px rgba(0,0,0,0.4), 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .players-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 25px;
        }
        
        .player {
            background: rgba(255,255,255,0.1);
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }
        
        .player:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0,0,0,0.3);
        }
        
        .player h3 {
            margin: 0 0 20px 0;
            color: #f39c12;
            font-size: 1.4em;
            text-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        .player-cards {
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
        }
        
        .probability {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #2ecc71;
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        .winner-btn {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
        }
        
        .winner-btn:hover {
            background: linear-gradient(135deg, #c0392b, #e74c3c);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(231, 76, 60, 0.5);
        }
        
        .winner-btn.selected {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.4);
        }
        
        .winner-btn.selected:hover {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            box-shadow: 0 8px 25px rgba(39, 174, 96, 0.5);
        }
        
        .message {
            text-align: center;
            padding: 25px;
            border-radius: 15px;
            margin: 25px 0;
            font-size: 18px;
            transition: all 0.3s ease;
            cursor: default;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .message:hover {
            transform: scale(1.02);
            box-shadow: 0 12px 40px rgba(0,0,0,0.3);
        }
        
        .success {
            background: rgba(39, 174, 96, 0.2);
            border: 2px solid rgba(39, 174, 96, 0.5);
        }
        
        .error {
            background: rgba(231, 76, 60, 0.2);
            border: 2px solid rgba(231, 76, 60, 0.5);
        }
        
        .hand-explanation {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
            font-size: 14px;
            transition: all 0.3s ease;
            cursor: default;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .hand-explanation:hover {
            background: rgba(255,255,255,0.15);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        /* Fixed Overlay for Explanations */
        .explanation-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .explanation-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        
        .explanation-content {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 40px;
            border-radius: 20px;
            width: 600px;
            min-height: 400px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.1);
            transform: scale(0.9) translateY(20px);
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            flex-direction: column;
        }
        
        .explanation-overlay.show .explanation-content {
            transform: scale(1) translateY(0);
        }
        
        .explanation-content h3 {
            margin: 0 0 20px 0;
            color: #f39c12;
            font-size: 1.8em;
            text-align: center;
            text-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        .explanation-content .hand-explanation {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            font-size: 16px;
            line-height: 1.6;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            flex: 1;
        }
        
        .explanation-content h3 {
            margin: 0 0 20px 0;
            color: #f39c12;
            font-size: 1.8em;
            text-align: center;
            text-shadow: 0 2px 8px rgba(0,0,0,0.3);
            flex-shrink: 0;
        }
        
        .close-explanation-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .close-explanation-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .message {
            text-align: center;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-size: 18px;
            transition: all 0.3s ease;
            cursor: default;
        }
        
        .message:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div class="container">
                <div class="header">
            <h1>🎰 Poker Hand Evaluator - Learning Game</h1>
            <p>Learn to evaluate poker hands by predicting winners at each stage</p>
            
            <!-- Instructions Button -->
            <button id="instructionsBtn" class="instructions-btn" onclick="toggleInstructions()">
                📖 How to Play
            </button>
            
            <!-- Instructions Panel -->
            <div id="instructionsPanel" class="instructions-panel" style="display: none;">
                <div class="instructions-content">
                    <h3>🎯 Game Instructions</h3>
                    
                    <h4>🎮 Objective</h4>
                    <p>Learn to evaluate poker hands by predicting winners at each stage of Texas Hold'em.</p>
                    
                    <h4>📋 How to Play</h4>
                    <ol>
                        <li><strong>Select Players:</strong> Choose 2-9 players using the dropdown</li>
                        <li><strong>Deal Cards:</strong> Click "Deal Cards" to give each player 2 hole cards</li>
                        <li><strong>Evaluate Preflop:</strong> See win probabilities and select who you think will win</li>
                        <li><strong>Deal Flop:</strong> Click "Deal Flop" to reveal 3 community cards</li>
                        <li><strong>Re-evaluate:</strong> Probabilities update - select your winner again</li>
                        <li><strong>Deal Turn:</strong> Click "Deal Turn" to reveal the 4th community card</li>
                        <li><strong>Final Evaluation:</strong> Select winner based on 6 visible cards</li>
                        <li><strong>Deal River:</strong> Click "Deal River" to reveal the final community card</li>
                        <li><strong>Final Winner:</strong> Select the ultimate winner with all 7 cards visible</li>
                    </ol>
                    
                    <h4>🏆 Hand Rankings (Best to Worst)</h4>
                    <ol>
                        <li><strong>Royal Flush:</strong> A, K, Q, J, 10 of same suit</li>
                        <li><strong>Straight Flush:</strong> 5 consecutive cards of same suit</li>
                        <li><strong>Four of a Kind:</strong> 4 cards of same rank</li>
                        <li><strong>Full House:</strong> 3 of a kind + 1 pair</li>
                        <li><strong>Flush:</strong> 5 cards of same suit</li>
                        <li><strong>Straight:</strong> 5 consecutive cards</li>
                        <li><strong>Three of a Kind:</strong> 3 cards of same rank</li>
                        <li><strong>Two Pair:</strong> 2 different pairs</li>
                        <li><strong>One Pair:</strong> 2 cards of same rank</li>
                        <li><strong>High Card:</strong> Highest card wins</li>
                    </ol>
                    
                    <h4>💡 Learning Tips</h4>
                    <ul>
                        <li>Start with 2-3 players to learn the basics</li>
                        <li>Pay attention to how probabilities change at each stage</li>
                        <li>Use the tooltips on cards to see hand descriptions</li>
                        <li>Learn from the detailed explanations after each prediction</li>
                        <li>Practice with different player counts to see various scenarios</li>
                    </ul>
                    
                    <button class="close-instructions-btn" onclick="toggleInstructions()">✕ Close</button>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="playerCount">Number of Players:</label>
                <select id="playerCount">
                    <option value="2">2 Players</option>
                    <option value="3">3 Players</option>
                    <option value="4">4 Players</option>
                    <option value="5">5 Players</option>
                    <option value="6">6 Players</option>
                    <option value="7">7 Players</option>
                    <option value="8">8 Players</option>
                    <option value="9">9 Players</option>
                </select>
            </div>
            
            <button id="dealBtn" onclick="dealCards()">Deal Cards</button>
            <button id="flopBtn" onclick="dealFlop()" disabled>Deal Flop</button>
            <button id="turnBtn" onclick="dealTurn()" disabled>Deal Turn</button>
            <button id="riverBtn" onclick="dealRiver()" disabled>Deal River</button>
            <button id="resetBtn" onclick="resetGame()" style="background: #e74c3c;">Reset Game</button>
        </div>
        
        <div class="game-area">
            <div class="community-cards">
                <h3>Community Cards</h3>
                <div id="communityCards"></div>
            </div>
            
            <div id="playersGrid" class="players-grid"></div>
            
                    <div id="messageArea"></div>
    </div>
    
    <!-- Fixed Explanation Overlay -->
    <div id="explanationOverlay" class="explanation-overlay">
        <div class="explanation-content">
            <button class="close-explanation-btn" onclick="closeExplanation()">Close</button>
            <div id="explanationContent"></div>
        </div>
    </div>
</div>

    <script>
        // Game state
        let gameState = {
            players: [],
            communityCards: [],
            deck: [],
            currentStage: 'preflop', // preflop, flop, turn, river
            selectedWinner: null
        };
        
        // Card suits and ranks
        const suits = ['♠', '♥', '♦', '♣'];
        const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        
        // Initialize game
        function initGame() {
            createDeck();
            shuffleDeck();
            setupPlayers();
            updateDisplay();
        }
        
        // Create and shuffle deck
        function createDeck() {
            gameState.deck = [];
            for (let suit of suits) {
                for (let rank of ranks) {
                    gameState.deck.push({ rank, suit, value: getCardValue(rank) });
                }
            }
        }
        
        function shuffleDeck() {
            for (let i = gameState.deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [gameState.deck[i], gameState.deck[j]] = [gameState.deck[j], gameState.deck[i]];
            }
        }
        
        function getCardValue(rank) {
            if (rank === 'A') return 14;
            if (rank === 'K') return 13;
            if (rank === 'Q') return 12;
            if (rank === 'J') return 11;
            return parseInt(rank);
        }
        
        // Setup players
        function setupPlayers() {
            const playerCount = parseInt(document.getElementById('playerCount').value);
            gameState.players = [];
            
            for (let i = 0; i < playerCount; i++) {
                gameState.players.push({
                    id: i,
                    name: `Player ${i + 1}`,
                    holeCards: [],
                    probability: 0,
                    isWinner: false
                });
            }
        }
        
        // Deal initial cards
        function dealCards() {
            if (gameState.currentStage !== 'preflop') {
                resetGame();
            }
            
            // Deal 2 cards to each player
            for (let player of gameState.players) {
                player.holeCards = [gameState.deck.pop(), gameState.deck.pop()];
            }
            
            gameState.currentStage = 'dealt';
            calculateProbabilities();
            updateDisplay();
            updateButtons();
            
            showMessage('Cards dealt! Select who you think will win, then deal the flop.', 'info');
        }
        
        // Deal flop
        function dealFlop() {
            if (gameState.currentStage !== 'dealt') return;
            
            gameState.communityCards = [
                gameState.deck.pop(),
                gameState.deck.pop(),
                gameState.deck.pop()
            ];
            
            gameState.currentStage = 'flop';
            calculateProbabilities();
            updateDisplay();
            updateButtons();
            
            showMessage('Flop dealt! Select who you think will win, then deal the turn.', 'info');
        }
        
        // Deal turn
        function dealTurn() {
            if (gameState.currentStage !== 'flop') return;
            
            gameState.communityCards.push(gameState.deck.pop());
            gameState.currentStage = 'turn';
            calculateProbabilities();
            updateDisplay();
            updateButtons();
            
            showMessage('Turn dealt! Select who you think will win, then deal the river.', 'info');
        }
        
        // Deal river
        function dealRiver() {
            if (gameState.currentStage !== 'turn') return;
            
            gameState.communityCards.push(gameState.deck.pop());
            gameState.currentStage = 'river';
            calculateProbabilities();
            updateDisplay();
            updateButtons();
            
            showMessage('River dealt! Select who you think will win, then evaluate!', 'info');
        }
        
        // Calculate winning probabilities
        function calculateProbabilities() {
            // Don't calculate probabilities if no cards are dealt yet
            if (gameState.currentStage === 'preflop') {
                for (let player of gameState.players) {
                    player.probability = 0;
                }
                return;
            }
            
            // Calculate probabilities based on current game stage
            for (let player of gameState.players) {
                let probability = 0;
                
                if (gameState.currentStage === 'dealt') {
                    // Preflop: based on hole card strength (0-100 scale)
                    probability = calculateHoleCardStrength(player.holeCards);
                } else {
                    // Post-flop: based on hand ranking and potential
                    probability = calculatePostFlopProbability(player.holeCards, gameState.communityCards, gameState.currentStage);
                }
                
                player.probability = Math.round(probability);
            }
            

            
            // Normalize probabilities to sum to 100%
            const total = gameState.players.reduce((sum, p) => sum + p.probability, 0);
            if (total > 0) {
                // For river stage, create more dramatic differences when one player has a clearly better hand
                if (gameState.currentStage === 'river') {
                    const maxProb = Math.max(...gameState.players.map(p => p.probability));
                    const minProb = Math.min(...gameState.players.map(p => p.probability));
                    
                    // If there's a significant difference in hand strength, make it more dramatic
                    if (maxProb - minProb > 1) {
                        // Give the strongest hand a much higher probability
                        for (let player of gameState.players) {
                            if (player.probability === maxProb) {
                                player.probability = 90; // Strong hand gets 90%
                            } else {
                                player.probability = Math.round((10 / (gameState.players.length - 1))); // Others share 10%
                            }
                        }
                    } else {
                        // Normal normalization for close hands
                        for (let player of gameState.players) {
                            player.probability = Math.round((player.probability / total) * 100);
                        }
                    }
                } else {
                    // Normal normalization for other stages
                    for (let player of gameState.players) {
                        player.probability = Math.round((player.probability / total) * 100);
                    }
                }
            } else {
                // If all probabilities are 0, distribute evenly
                const equalProb = Math.round(100 / gameState.players.length);
                for (let player of gameState.players) {
                    player.probability = equalProb;
                }
            }
            
            // Ensure at least one player has a non-zero probability
            const maxProb = Math.max(...gameState.players.map(p => p.probability));
            if (maxProb === 0) {
                gameState.players[0].probability = 100;
            }
        }
        
        // Calculate probability for post-flop hands
        function calculatePostFlopProbability(holeCards, communityCards, stage) {
            const handRank = getHandRankAtStage([...holeCards, ...communityCards], stage);
            let probability = 0;
            
            // Base probability from hand strength
            switch (handRank.name) {
                case 'Royal Flush':
                case 'Straight Flush':
                    probability = 95;
                    break;
                case 'Four of a Kind':
                    probability = 90;
                    break;
                case 'Full House':
                    probability = 85;
                    break;
                case 'Flush':
                    probability = 80;
                    break;
                case 'Straight':
                    probability = 75;
                    break;
                case 'Three of a Kind':
                    probability = 70;
                    break;
                case 'Two Pair':
                    probability = 65;
                    break;
                case 'One Pair':
                    probability = 60;
                    break;
                case 'High Card':
                    probability = 40;
                    break;
            }
            
            // Adjust based on remaining cards to be dealt
            if (stage === 'flop') {
                // 2 more cards coming - high potential for improvement
                // Add potential bonus based on hand type
                if (handRank.name === 'High Card') {
                    probability += 15; // High potential to improve
                } else if (handRank.name === 'One Pair') {
                    probability += 10; // Moderate potential
                } else if (handRank.name === 'Two Pair') {
                    probability += 5; // Low potential
                }
            } else if (stage === 'turn') {
                // 1 more card coming - moderate potential
                if (handRank.name === 'High Card') {
                    probability += 8; // Moderate potential
                } else if (handRank.name === 'One Pair') {
                    probability += 5; // Low potential
                }
            } else if (stage === 'river') {
                // Final hand - no more improvement possible
                // For river stage, use hand score directly for more accurate probabilities
                const score = handRank.score;
                if (score >= 800) probability = 99; // Royal Flush
                else if (score >= 700) probability = 98; // Four of a Kind
                else if (score >= 600) probability = 97; // Full House
                else if (score >= 500) probability = 95; // Flush
                else if (score >= 400) probability = 92; // Straight
                else if (score >= 300) probability = 88; // Three of a Kind
                else if (score >= 200) probability = 80 + (score - 200) / 5; // Two Pair (80 + score bonus, more sensitive)
                else if (score >= 100) probability = 75 + (score - 100) / 10; // One Pair (75 + score bonus)
                else probability = 60 + score; // High Card (60 + card value)
            }
            
            // Ensure probability stays within bounds
            return Math.min(100, Math.max(0, probability));
        }
        
        function calculateHoleCardStrength(holeCards) {
            // Return 0 if no cards are dealt
            if (!holeCards || holeCards.length < 2) {
                return 0;
            }
            
            let strength = 0;
            
            // High card value (0-14 scale, convert to 0-20)
            strength += Math.max(holeCards[0].value, holeCards[1].value) * 1.4;
            
            // Pairs (biggest boost)
            if (holeCards[0].value === holeCards[1].value) {
                strength += 40;
            }
            
            // Suited cards
            if (holeCards[0].suit === holeCards[1].suit) {
                strength += 15;
            }
            
            // Connected cards
            const diff = Math.abs(holeCards[0].value - holeCards[1].value);
            if (diff === 1) strength += 20; // Connected
            if (diff === 2) strength += 15; // 1 gap
            if (diff === 3) strength += 10; // 2 gap
            
            // Ensure strength stays within 0-100 range
            return Math.min(100, Math.max(0, strength));
        }
        
        function evaluateHandStrength(holeCards, communityCards) {
            const allCards = [...holeCards, ...communityCards];
            const handRank = getHandRank(allCards);
            return handRank.score;
        }
        
        function getHandRank(cards) {
            // Find the best 5-card hand from the available cards
            return findBestFiveCardHand(cards);
        }
        
        function findBestFiveCardHand(cards) {
            // If we have exactly 5 cards, evaluate them directly
            if (cards.length === 5) {
                return evaluateFiveCards(cards);
            }
            
            // If we have more than 5 cards, find the best 5-card combination
            if (cards.length > 5) {
                const combinations = getCombinations(cards, 5);
                let bestHand = { name: 'High Card', score: 0 };
                
                for (let combination of combinations) {
                    const hand = evaluateFiveCards(combination);
                    if (hand.score > bestHand.score) {
                        bestHand = hand;
                    }
                }
                
                return bestHand;
            }
            
            // If we have fewer than 5 cards, evaluate what we have
            return evaluateFiveCards(cards);
        }
        
        function evaluateFiveCards(cards) {
            // Enhanced hand ranking with pair values for exactly 5 cards
            const sorted = cards.sort((a, b) => b.value - a.value);
            const counts = {};
            const suits = {};
            
            for (let card of cards) {
                counts[card.value] = (counts[card.value] || 0) + 1;
                suits[card.suit] = (suits[card.suit] || 0) + 1;
            }
            
            const pairs = Object.values(counts).filter(c => c >= 2);
            const isFlush = Object.values(suits).some(c => c >= 5);
            const isStraight = checkStraight(sorted);
            
            if (isFlush && isStraight) return { name: 'Straight Flush', score: 800 };
            if (pairs.includes(4)) return { name: 'Four of a Kind', score: 700 };
            if (pairs.includes(3) && pairs.includes(2)) return { name: 'Full House', score: 600 };
            if (isFlush) return { name: 'Flush', score: 500 };
            if (isStraight) return { name: 'Straight', score: 400 };
            if (pairs.includes(3)) return { name: 'Three of a Kind', score: 300 };
            // Check for Two Pair - count how many values have exactly 2 cards
            const pairValues = Object.entries(counts)
                .filter(([value, count]) => count === 2)
                .map(([value, count]) => parseInt(value))
                .sort((a, b) => b - a); // Sort pairs in descending order
            
            if (pairValues.length >= 2) {
                // Two Pair - include the values of the pairs in the score
                const kicker = sorted.find(card => card.value !== pairValues[0] && card.value !== pairValues[1]);
                const score = 200 + (pairValues[0] * 10) + pairValues[1] + (kicker ? kicker.value : 0);
                console.log(`Two Pair detected: ${pairValues[0]}s and ${pairValues[1]}s with ${kicker ? getCardName(kicker) : 'no'} kicker`);
                return { name: 'Two Pair', score: score };
            }
            if (pairs.includes(2)) {
                // One Pair - include the pair value and kickers in the score
                const pairValue = Object.entries(counts).find(([value, count]) => count === 2)[0];
                const kickers = sorted.filter(card => card.value !== parseInt(pairValue)).slice(0, 3);
                const kickerSum = kickers.reduce((sum, card) => sum + card.value, 0);
                const score = 100 + (parseInt(pairValue) * 10) + kickerSum;
                console.log(`One Pair detected: ${getCardName({ value: parseInt(pairValue), suit: '♠' })}s with kickers: ${kickers.map(k => getCardName(k)).join(', ')}`);
                return { name: 'One Pair', score: score };
            }
            
            return { name: 'High Card', score: sorted[0].value };
        }
        
        // Helper function to get all combinations of n cards from a set of cards
        function getCombinations(cards, n) {
            if (n === 0) return [[]];
            if (cards.length === 0) return [];
            
            const combinations = [];
            
            for (let i = 0; i <= cards.length - n; i++) {
                const current = cards[i];
                const remaining = cards.slice(i + 1);
                const subCombinations = getCombinations(remaining, n - 1);
                
                for (let subCombination of subCombinations) {
                    combinations.push([current, ...subCombination]);
                }
            }
            
            return combinations;
        }
        
        function checkStraight(cards) {
            // Sort cards in descending order
            const sorted = cards.sort((a, b) => b.value - a.value);
            
            // Check for 5 consecutive cards
            for (let i = 0; i <= sorted.length - 5; i++) {
                let consecutive = true;
                for (let j = 0; j < 4; j++) {
                    if (sorted[i + j].value - sorted[i + j + 1].value !== 1) {
                        consecutive = false;
                        break;
                    }
                }
                if (consecutive) {
                    return true;
                }
            }
            return false;
        }
        
        // Helper function to get high card name
        function getHighCardName(cards) {
            const sorted = cards.sort((a, b) => b.value - a.value);
            const highCard = sorted[0];
            
            // Convert numeric values to card names
            let cardName = '';
            switch (highCard.value) {
                case 14: cardName = 'Ace'; break;
                case 13: cardName = 'King'; break;
                case 12: cardName = 'Queen'; break;
                case 11: cardName = 'Jack'; break;
                default: cardName = highCard.value.toString();
            }
            
            return `${cardName} of ${getSuitName(highCard.suit)}`;
        }
        
        // Helper function to get suit name
        function getSuitName(suit) {
            switch (suit) {
                case '♠': return 'Spades';
                case '♥': return 'Hearts';
                case '♦': return 'Diamonds';
                case '♣': return 'Clubs';
                default: return suit;
            }
        }
        
        // New function to find all winners (handles ties)
        function findWinners() {
            let bestScore = -1;
            let winners = [];
            
            // First pass: find the best score based on current game stage
            for (let i = 0; i < gameState.players.length; i++) {
                const score = evaluateHandStrengthAtStage(gameState.players[i].holeCards, gameState.communityCards, gameState.currentStage);
                if (score > bestScore) {
                    bestScore = score;
                }
            }
            
            // Second pass: find all players with the best score
            for (let i = 0; i < gameState.players.length; i++) {
                const score = evaluateHandStrengthAtStage(gameState.players[i].holeCards, gameState.communityCards, gameState.currentStage);
                if (score === bestScore) {
                    winners.push({
                        id: i,
                        name: gameState.players[i].name,
                        holeCards: gameState.players[i].holeCards,
                        score: score
                    });
                }
            }
            
            // If there are ties, break them with kickers
            if (winners.length > 1) {
                winners = breakTies(winners);
            }
            
            return winners;
        }
        
        // New function to break ties using kickers
        function breakTies(winners) {
            if (winners.length <= 1) return winners;
            
            // Get the hand type for all winners based on current stage
            const handType = getHandRankAtStage([...winners[0].holeCards, ...gameState.communityCards], gameState.currentStage).name;
            
            // For different hand types, we need different tie-breaking logic
            if (handType === 'High Card') {
                return breakHighCardTie(winners);
            } else if (handType === 'One Pair') {
                return breakOnePairTie(winners);
            } else if (handType === 'Two Pair') {
                return breakTwoPairTie(winners);
            } else if (handType === 'Three of a Kind') {
                return breakThreeOfAKindTie(winners);
            } else if (handType === 'Straight') {
                return breakStraightTie(winners);
            } else if (handType === 'Flush') {
                return breakFlushTie(winners);
            } else if (handType === 'Full House') {
                return breakFullHouseTie(winners);
            } else if (handType === 'Four of a Kind') {
                return breakFourOfAKindTie(winners);
            } else if (handType === 'Straight Flush') {
                return breakStraightTie(winners); // Same as straight
            }
            
            // For hands that can't tie (like Royal Flush), return all winners
            return winners;
        }
        
        // Helper function to break high card ties
        function breakHighCardTie(winners) {
            // Sort winners by their 5 highest cards (kickers)
            winners.sort((a, b) => {
                const aCards = [...a.holeCards, ...gameState.communityCards].sort((x, y) => y.value - x.value).slice(0, 5);
                const bCards = [...b.holeCards, ...gameState.communityCards].sort((x, y) => y.value - x.value).slice(0, 5);
                
                for (let i = 0; i < 5; i++) {
                    if (aCards[i].value !== bCards[i].value) {
                        return bCards[i].value - aCards[i].value;
                    }
                }
                return 0; // Complete tie
            });
            
            // Return only the highest (first after sorting)
            return [winners[0]];
        }
        
        // Helper function to break one pair ties
        function breakOnePairTie(winners) {
            // Sort by pair value first, then by kickers
            winners.sort((a, b) => {
                const aPair = findPairValue([...a.holeCards, ...gameState.communityCards]);
                const bPair = findPairValue([...b.holeCards, ...gameState.communityCards]);
                
                if (aPair !== bPair) {
                    return bPair - aPair;
                }
                
                // Same pair, check kickers
                const aKickers = getKickers([...a.holeCards, ...gameState.communityCards], aPair);
                const bKickers = getKickers([...b.holeCards, ...gameState.communityCards], bPair);
                
                for (let i = 0; i < 3; i++) {
                    if (aKickers[i] !== bKickers[i]) {
                        return bKickers[i] - aKickers[i];
                    }
                }
                return 0;
            });
            
            return [winners[0]];
        }
        
        // Helper function to find pair value
        function findPairValue(cards) {
            const counts = {};
            for (let card of cards) {
                counts[card.value] = (counts[card.value] || 0) + 1;
            }
            for (let [value, count] of Object.entries(counts)) {
                if (count === 2) return parseInt(value);
            }
            return 0;
        }
        
        // Helper function to get kickers (excluding the pair)
        function getKickers(cards, pairValue) {
            return cards
                .filter(card => card.value !== pairValue)
                .sort((a, b) => b.value - a.value)
                .slice(0, 3)
                .map(card => card.value);
        }
        
        // Placeholder functions for other tie-breaking scenarios
        function breakTwoPairTie(winners) { return [winners[0]]; }
        function breakThreeOfAKindTie(winners) { return [winners[0]]; }
        function breakStraightTie(winners) { return [winners[0]]; }
        function breakFlushTie(winners) { return [winners[0]]; }
        function breakFullHouseTie(winners) { return [winners[0]]; }
        function breakFourOfAKindTie(winners) { return [winners[0]]; }
        
        // Function to show explanation overlay
        function showExplanationOverlay(content) {
            document.getElementById('explanationContent').innerHTML = content;
            document.getElementById('explanationOverlay').classList.add('show');
        }
        
        // Function to close explanation overlay
        function closeExplanation() {
            document.getElementById('explanationOverlay').classList.remove('show');
        }
        
        // Close overlay when clicking outside
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('explanationOverlay').addEventListener('click', function(e) {
                if (e.target === this) {
                    closeExplanation();
                }
            });
        });
        
        // Function to get detailed explanation of why a player won
        function getDetailedWinExplanation(selectedPlayer, actualWinner) {
            const selectedHand = getHandRankAtStage([...selectedPlayer.holeCards, ...gameState.communityCards], gameState.currentStage);
            const actualHand = getHandRankAtStage([...actualWinner.holeCards, ...gameState.communityCards], gameState.currentStage);
            
            // If hands are different types, explain the hand ranking
            if (selectedHand.name !== actualHand.name) {
                return `${selectedPlayer.name} has ${selectedHand.name} but ${actualWinner.name} has ${actualHand.name}. ${actualHand.name} beats ${selectedHand.name} in poker hand rankings.`;
            }
            
            // If hands are the same type, explain why one is better
            if (selectedHand.name === 'High Card') {
                return getHighCardComparison(selectedPlayer, actualWinner);
            } else if (selectedHand.name === 'One Pair') {
                return getOnePairComparison(selectedPlayer, actualWinner);
            } else if (selectedHand.name === 'Two Pair') {
                return getTwoPairComparison(selectedPlayer, actualWinner);
            } else if (selectedHand.name === 'Three of a Kind') {
                return getThreeOfAKindComparison(selectedPlayer, actualWinner);
            } else if (selectedHand.name === 'Straight') {
                return getStraightComparison(selectedPlayer, actualWinner);
            } else if (selectedHand.name === 'Flush') {
                return getFlushComparison(selectedPlayer, actualWinner);
            } else if (selectedHand.name === 'Full House') {
                return getFullHouseComparison(selectedPlayer, actualWinner);
            } else if (selectedHand.name === 'Four of a Kind') {
                return getFourOfAKindComparison(selectedPlayer, actualWinner);
            } else if (selectedHand.name === 'Straight Flush') {
                return getStraightFlushComparison(selectedPlayer, actualWinner);
            } else if (selectedHand.name === 'Royal Flush') {
                return getRoyalFlushComparison(selectedPlayer, actualWinner);
            }
            
            return `Both players have ${selectedHand.name}, but ${actualWinner.name} has a stronger version.`;
        }
        
        // Function to get tie explanation
        function getTieExplanation(winners) {
            const handType = getHandRankAtStage([...winners[0].holeCards, ...gameState.communityCards], gameState.currentStage).name;
            const winnerNames = winners.map(w => w.name).join(', ');
            
            // Get detailed hand information for the first winner to show what they all have
            const firstWinner = winners[0];
            const handDetails = getDetailedHandDescriptionForTie(firstWinner, handType);
            
            // Check if this is a community card tie (all players using the same 5 community cards)
            const isCommunityCardTie = checkIfCommunityCardTie(winners);
            
            let tieMessage = `🏆 TIE! ${winnerNames} have tied with identical ${handType}${handDetails}.`;
            
            if (isCommunityCardTie) {
                tieMessage += ` All players are using the same 5 community cards as their best hand, making this a true tie.`;
            } else {
                tieMessage += ` All kickers were evaluated and found to be exactly the same, making this a true tie.`;
            }
            
            return tieMessage;
        }
        
        // Helper function to check if all players are using the same community cards
        function checkIfCommunityCardTie(winners) {
            if (winners.length < 2) return false;
            
            // Get the best 5-card hand for each player
            const playerHands = winners.map(w => {
                const allCards = [...w.holeCards, ...gameState.communityCards];
                return findBestFiveCardHand(allCards);
            });
            
            // Check if all hands are identical
            const firstHand = playerHands[0];
            for (let i = 1; i < playerHands.length; i++) {
                if (playerHands[i].name !== firstHand.name || playerHands[i].score !== firstHand.score) {
                    return false;
                }
            }
            
            // If all hands are identical, check if they're all using the same 5 cards
            // This is a simplified check - in practice, we'd need to compare the actual cards used
            return true;
        }
        
        // Helper function to get detailed hand description for tie explanation
        function getDetailedHandDescriptionForTie(player, handType) {
            const cards = [...player.holeCards, ...gameState.communityCards];
            
            switch (handType) {
                case 'High Card':
                    const highCard = getHighCardName(cards);
                    return ` (${highCard})`;
                    
                case 'One Pair':
                    const pairValue = findPairValue(cards);
                    const pairName = getCardName({ value: pairValue, suit: '♠' });
                    const kickers = getKickers(cards, pairValue);
                    const kickerNames = kickers.map(k => getCardName({ value: k, suit: '♠' })).join(', ');
                    return ` (${pairName}s with ${kickerNames} kickers)`;
                    
                case 'Two Pair':
                    const pairValues = Object.entries(getCardCounts(cards))
                        .filter(([value, count]) => count === 2)
                        .map(([value, count]) => parseInt(value))
                        .sort((a, b) => b - a);
                    const kicker = cards.find(card => card.value !== pairValues[0] && card.value !== pairValues[1]);
                    return ` (${getCardName({ value: pairValues[0], suit: '♠' })}s and ${getCardName({ value: pairValues[1], suit: '♠' })}s with ${getCardName(kicker)} kicker)`;
                    
                case 'Three of a Kind':
                    const threeValue = Object.entries(getCardCounts(cards)).find(([value, count]) => count === 3)[0];
                    const threeKickers = cards
                        .filter(card => card.value !== parseInt(threeValue))
                        .sort((a, b) => b.value - a.value)
                        .slice(0, 2)
                        .map(card => getCardName(card))
                        .join(', ');
                    return ` (${getCardName({ value: parseInt(threeValue), suit: '♠' })}s with ${threeKickers} kickers)`;
                    
                case 'Straight':
                    const straight = findHighestStraight(cards);
                    return ` (${getCardName(straight[0])} high)`;
                    
                case 'Flush':
                    const suits = {};
                    for (let card of cards) {
                        suits[card.suit] = (suits[card.suit] || 0) + 1;
                    }
                    const flushSuit = Object.entries(suits).find(([suit, count]) => count >= 5)[0];
                    const flushCards = cards
                        .filter(card => card.suit === flushSuit)
                        .sort((a, b) => b.value - a.value)
                        .slice(0, 5)
                        .map(card => getCardName(card))
                        .join(', ');
                    return ` (${getSuitName(flushSuit)} flush: ${flushCards})`;
                    
                case 'Full House':
                    const counts = getCardCounts(cards);
                    const threeVal = Object.entries(counts).find(([value, count]) => count === 3)[0];
                    const twoVal = Object.entries(counts).find(([value, count]) => count === 2)[0];
                    return ` (${getCardName({ value: parseInt(threeVal), suit: '♠' })}s full of ${getCardName({ value: parseInt(twoVal), suit: '♠' })}s)`;
                    
                case 'Four of a Kind':
                    const fourValue = Object.entries(counts).find(([value, count]) => count === 4)[0];
                    const fourKicker = cards.find(card => card.value !== parseInt(fourValue));
                    return ` (${getCardName({ value: parseInt(fourValue), suit: '♠' })}s with ${getCardName(fourKicker)} kicker)`;
                    
                case 'Straight Flush':
                    const straightFlush = findHighestStraight(cards);
                    const flushSuit2 = straightFlush[0].suit;
                    return ` (${getCardName(straightFlush[0])} high ${getSuitName(flushSuit2)} straight flush)`;
                    
                case 'Royal Flush':
                    return ` (${getSuitName(cards[0].suit)} royal flush)`;
                    
                default:
                    return '';
            }
        }
        
        // Detailed comparison functions for different hand types
        function getHighCardComparison(selectedPlayer, actualWinner) {
            const selectedCards = [...selectedPlayer.holeCards, ...gameState.communityCards].sort((a, b) => b.value - a.value).slice(0, 5);
            const actualCards = [...actualWinner.holeCards, ...gameState.communityCards].sort((a, b) => b.value - a.value).slice(0, 5);
            
            for (let i = 0; i < 5; i++) {
                if (selectedCards[i].value !== actualCards[i].value) {
                    const selectedCardName = getCardName(selectedCards[i]);
                    const actualCardName = getCardName(actualCards[i]);
                    if (i === 0) {
                        return `${selectedPlayer.name} has ${selectedCardName} as high card, but ${actualWinner.name} has ${actualCardName}. ${actualCardName} beats ${selectedCardName}.`;
                    } else if (i === 1) {
                        return `Both players have the same highest card, but ${actualWinner.name} wins with ${actualCardName} second highest vs ${selectedPlayer.name}'s ${selectedCardName} second highest.`;
                    } else if (i === 2) {
                        return `Both players have the same two highest cards, but ${actualWinner.name} wins with ${actualCardName} third highest vs ${selectedPlayer.name}'s ${selectedCardName} third highest.`;
                    } else if (i === 3) {
                        return `Both players have the same three highest cards, but ${actualWinner.name} wins with ${actualCardName} fourth highest vs ${selectedPlayer.name}'s ${selectedCardName} fourth highest.`;
                    } else {
                        return `Both players have the same four highest cards, but ${actualWinner.name} wins with ${actualCardName} fifth highest vs ${selectedPlayer.name}'s ${selectedCardName} fifth highest.`;
                    }
                }
            }
            return `Both players have identical high cards. This should be a tie, but ${actualWinner.name} wins due to suit ranking.`;
        }
        
        function getOnePairComparison(selectedPlayer, actualWinner) {
            const selectedPair = findPairValue([...selectedPlayer.holeCards, ...gameState.communityCards]);
            const actualPair = findPairValue([...actualWinner.holeCards, ...gameState.communityCards]);
            
            if (selectedPair !== actualPair) {
                const selectedPairName = getCardName({ value: selectedPair, suit: '♠' });
                const actualPairName = getCardName({ value: actualPair, suit: '♠' });
                return `${selectedPlayer.name} has a pair of ${selectedPairName}s, but ${actualWinner.name} has a pair of ${actualPairName}s. ${actualPairName}s beat ${selectedPairName}s.`;
            }
            
            // Same pair, compare kickers
            const selectedKickers = getKickers([...selectedPlayer.holeCards, ...gameState.communityCards], selectedPair);
            const actualKickers = getKickers([...actualWinner.holeCards, ...gameState.communityCards], actualPair);
            
            for (let i = 0; i < 3; i++) {
                if (selectedKickers[i] !== actualKickers[i]) {
                    const selectedKickerName = getCardName({ value: selectedKickers[i], suit: '♠' });
                    const actualKickerName = getCardName({ value: actualKickers[i], suit: '♠' });
                    
                    if (i === 0) {
                        return `Both players have the same pair of ${getCardName({ value: selectedPair, suit: '♠' })}s, but ${actualWinner.name} wins with ${actualKickerName} kicker vs ${selectedPlayer.name}'s ${selectedKickerName} kicker.`;
                    } else if (i === 1) {
                        return `Both players have the same pair of ${getCardName({ value: selectedPair, suit: '♠' })}s and same highest kicker, but ${actualWinner.name} wins with ${actualKickerName} second kicker vs ${selectedPlayer.name}'s ${selectedKickerName} second kicker.`;
                    } else {
                        return `Both players have the same pair of ${getCardName({ value: selectedPair, suit: '♠' })}s and same two highest kickers, but ${actualWinner.name} wins with ${actualKickerName} third kicker vs ${selectedPlayer.name}'s ${selectedKickerName} third kicker.`;
                    }
                }
            }
            
            return `Both players have identical pairs and kickers. This should be a tie, but ${actualWinner.name} wins due to suit ranking.`;
        }
        
        function getTwoPairComparison(selectedPlayer, actualWinner) {
            // Get the pair values for both players
            const selectedCards = [...selectedPlayer.holeCards, ...gameState.communityCards];
            const actualCards = [...actualWinner.holeCards, ...gameState.communityCards];
            
            const selectedPairValues = Object.entries(getCardCounts(selectedCards))
                .filter(([value, count]) => count === 2)
                .map(([value, count]) => parseInt(value))
                .sort((a, b) => b - a);
            
            const actualPairValues = Object.entries(getCardCounts(actualCards))
                .filter(([value, count]) => count === 2)
                .map(([value, count]) => parseInt(value))
                .sort((a, b) => b - a);
            
            // Compare high pairs first
            if (selectedPairValues[0] !== actualPairValues[0]) {
                const selectedHighPair = getCardName({ value: selectedPairValues[0], suit: '♠' });
                const actualHighPair = getCardName({ value: actualPairValues[0], suit: '♠' });
                return `${selectedPlayer.name} has Two Pair: ${selectedHighPair}s and ${getCardName({ value: selectedPairValues[1], suit: '♠' })}s, but ${actualWinner.name} has Two Pair: ${actualHighPair}s and ${getCardName({ value: actualPairValues[1], suit: '♠' })}s. ${actualHighPair}s beat ${selectedHighPair}s.`;
            }
            
            // Same high pair, compare low pairs
            if (selectedPairValues[1] !== actualPairValues[1]) {
                const selectedLowPair = getCardName({ value: selectedPairValues[1], suit: '♠' });
                const actualLowPair = getCardName({ value: actualPairValues[1], suit: '♠' });
                return `Both players have Two Pair with ${getCardName({ value: selectedPairValues[0], suit: '♠' })}s as high pair, but ${actualWinner.name} wins with ${actualLowPair}s vs ${selectedPlayer.name}'s ${selectedLowPair}s as second pair.`;
            }
            
            // Same pairs, compare kickers
            const selectedKicker = selectedCards.find(card => card.value !== selectedPairValues[0] && card.value !== selectedPairValues[1]);
            const actualKicker = actualCards.find(card => card.value !== actualPairValues[0] && card.value !== actualPairValues[1]);
            
            if (selectedKicker.value !== actualKicker.value) {
                const selectedKickerName = getCardName(selectedKicker);
                const actualKickerName = getCardName(actualKicker);
                return `Both players have identical Two Pair (${getCardName({ value: selectedPairValues[0], suit: '♠' })}s and ${getCardName({ value: selectedPairValues[1], suit: '♠' })}s), but ${actualWinner.name} wins with ${actualKickerName} kicker vs ${selectedPlayer.name}'s ${selectedKickerName} kicker.`;
            }
            
            return `Both players have identical Two Pair and kickers. This should be a tie, but ${actualWinner.name} wins due to suit ranking.`;
        }
        
        // Helper function to get card counts
        function getCardCounts(cards) {
            const counts = {};
            for (let card of cards) {
                counts[card.value] = (counts[card.value] || 0) + 1;
            }
            return counts;
        }
        
        function getThreeOfAKindComparison(selectedPlayer, actualWinner) {
            const selectedCards = [...selectedPlayer.holeCards, ...gameState.communityCards];
            const actualCards = [...actualWinner.holeCards, ...gameState.communityCards];
            
            const selectedCounts = getCardCounts(selectedCards);
            const actualCounts = getCardCounts(actualCards);
            
            const selectedThreeValue = Object.entries(selectedCounts).find(([value, count]) => count === 3)[0];
            const actualThreeValue = Object.entries(actualCounts).find(([value, count]) => count === 3)[0];
            
            if (selectedThreeValue !== actualThreeValue) {
                const selectedThreeName = getCardName({ value: parseInt(selectedThreeValue), suit: '♠' });
                const actualThreeName = getCardName({ value: parseInt(actualThreeValue), suit: '♠' });
                return `${selectedPlayer.name} has Three of a Kind: ${selectedThreeName}s, but ${actualWinner.name} has Three of a Kind: ${actualThreeName}s. ${actualThreeName}s beat ${selectedThreeName}s.`;
            }
            
            // Same three of a kind, compare kickers
            const selectedKickers = selectedCards
                .filter(card => card.value !== parseInt(selectedThreeValue))
                .sort((a, b) => b.value - a.value)
                .slice(0, 2);
            
            const actualKickers = actualCards
                .filter(card => card.value !== parseInt(actualThreeValue))
                .sort((a, b) => b.value - a.value)
                .slice(0, 2);
            
            for (let i = 0; i < 2; i++) {
                if (selectedKickers[i].value !== actualKickers[i].value) {
                    const selectedKickerName = getCardName(selectedKickers[i]);
                    const actualKickerName = getCardName(actualKickers[i]);
                    return `Both players have Three of a Kind: ${getCardName({ value: parseInt(selectedThreeValue), suit: '♠' })}s, but ${actualWinner.name} wins with ${actualKickerName} kicker vs ${selectedPlayer.name}'s ${selectedKickerName} kicker.`;
                }
            }
            
            return `Both players have identical Three of a Kind and kickers. This should be a tie, but ${actualWinner.name} wins due to suit ranking.`;
        }
        
        function getStraightComparison(selectedPlayer, actualWinner) {
            const selectedCards = [...selectedPlayer.holeCards, ...gameState.communityCards];
            const actualCards = [...actualWinner.holeCards, ...gameState.communityCards];
            
            // Find the highest straight for each player
            const selectedStraight = findHighestStraight(selectedCards);
            const actualStraight = findHighestStraight(actualCards);
            
            if (selectedStraight[0].value !== actualStraight[0].value) {
                const selectedTopCard = getCardName(selectedStraight[0]);
                const actualTopCard = getCardName(actualStraight[0]);
                return `Both players have a Straight, but ${actualWinner.name} has ${actualTopCard} high vs ${selectedPlayer.name}'s ${selectedTopCard} high. ${actualTopCard} beats ${selectedTopCard}.`;
            }
            
            return `Both players have identical Straight. This should be a tie, but ${actualWinner.name} wins due to suit ranking.`;
        }
        
        // Helper function to find the highest straight
        function findHighestStraight(cards) {
            const sorted = cards.sort((a, b) => b.value - a.value);
            
            // Check for 5 consecutive cards starting from the highest
            for (let i = 0; i <= sorted.length - 5; i++) {
                let consecutive = true;
                for (let j = 0; j < 4; j++) {
                    if (sorted[i + j].value - sorted[i + j + 1].value !== 1) {
                        consecutive = false;
                        break;
                    }
                }
                if (consecutive) {
                    return sorted.slice(i, i + 5);
                }
            }
            return [];
        }
        
        function getFlushComparison(selectedPlayer, actualWinner) {
            const selectedCards = [...selectedPlayer.holeCards, ...gameState.communityCards];
            const actualCards = [...actualWinner.holeCards, ...gameState.communityCards];
            
            // Find the flush suit
            const selectedSuits = {};
            const actualSuits = {};
            
            for (let card of selectedCards) {
                selectedSuits[card.suit] = (selectedSuits[card.suit] || 0) + 1;
            }
            for (let card of actualCards) {
                actualSuits[card.suit] = (actualSuits[card.suit] || 0) + 1;
            }
            
            const selectedFlushSuit = Object.entries(selectedSuits).find(([suit, count]) => count >= 5)[0];
            const actualFlushSuit = Object.entries(actualSuits).find(([suit, count]) => count >= 5)[0];
            
            // If different suits, the higher suit wins (this is a simplified rule)
            if (selectedFlushSuit !== actualFlushSuit) {
                return `Both players have a Flush, but ${actualWinner.name} has ${getSuitName(actualFlushSuit)} flush vs ${selectedPlayer.name}'s ${getSuitName(selectedFlushSuit)} flush. ${getSuitName(actualFlushSuit)} flush beats ${getSuitName(selectedFlushSuit)} flush.`;
            }
            
            const selectedFlushCards = selectedCards
                .filter(card => card.suit === selectedFlushSuit)
                .sort((a, b) => b.value - a.value)
                .slice(0, 5);
            
            const actualFlushCards = actualCards
                .filter(card => card.suit === actualFlushSuit)
                .sort((a, b) => b.value - a.value)
                .slice(0, 5);
            
            for (let i = 0; i < 5; i++) {
                if (selectedFlushCards[i].value !== actualFlushCards[i].value) {
                    const selectedCardName = getCardName(selectedFlushCards[i]);
                    const actualCardName = getCardName(actualFlushCards[i]);
                    if (i === 0) {
                        return `Both players have a ${getSuitName(selectedFlushSuit)} flush, but ${actualWinner.name} has ${actualCardName} vs ${selectedPlayer.name}'s ${selectedCardName} as the highest card.`;
                    } else {
                        return `Both players have the same ${i} highest cards in their ${getSuitName(selectedFlushSuit)} flush, but ${actualWinner.name} wins with ${actualCardName} vs ${selectedPlayer.name}'s ${selectedCardName}.`;
                    }
                }
            }
            
            return `Both players have identical ${getSuitName(selectedFlushSuit)} flush. This should be a tie, but ${actualWinner.name} wins due to suit ranking.`;
        }
        
        function getFullHouseComparison(selectedPlayer, actualWinner) {
            const selectedCards = [...selectedPlayer.holeCards, ...gameState.communityCards];
            const actualCards = [...actualWinner.holeCards, ...gameState.communityCards];
            
            const selectedCounts = getCardCounts(selectedCards);
            const actualCounts = getCardCounts(actualCards);
            
            const selectedThreeValue = Object.entries(selectedCounts).find(([value, count]) => count === 3)[0];
            const actualThreeValue = Object.entries(actualCounts).find(([value, count]) => count === 3)[0];
            
            const selectedTwoValue = Object.entries(selectedCounts).find(([value, count]) => count === 2)[0];
            const actualTwoValue = Object.entries(actualCounts).find(([value, count]) => count === 2)[0];
            
            if (selectedThreeValue !== actualThreeValue) {
                const selectedThreeName = getCardName({ value: parseInt(selectedThreeValue), suit: '♠' });
                const actualThreeName = getCardName({ value: parseInt(actualThreeValue), suit: '♠' });
                return `${selectedPlayer.name} has Full House: ${selectedThreeName}s full of ${getCardName({ value: parseInt(selectedTwoValue), suit: '♠' })}s, but ${actualWinner.name} has Full House: ${actualThreeName}s full of ${getCardName({ value: parseInt(actualTwoValue), suit: '♠' })}s. ${actualThreeName}s beat ${selectedThreeName}s.`;
            }
            
            // Same three of a kind, compare the pair
            if (selectedTwoValue !== actualTwoValue) {
                const selectedTwoName = getCardName({ value: parseInt(selectedTwoValue), suit: '♠' });
                const actualTwoName = getCardName({ value: parseInt(actualTwoValue), suit: '♠' });
                return `Both players have Full House with ${getCardName({ value: parseInt(selectedThreeValue), suit: '♠' })}s as three of a kind, but ${actualWinner.name} wins with ${actualTwoName}s vs ${selectedPlayer.name}'s ${selectedTwoName}s as the pair.`;
            }
            
            return `Both players have identical Full House. This should be a tie, but ${actualWinner.name} wins due to suit ranking.`;
        }
        
        function getFourOfAKindComparison(selectedPlayer, actualWinner) {
            const selectedCards = [...selectedPlayer.holeCards, ...gameState.communityCards];
            const actualCards = [...actualWinner.holeCards, ...gameState.communityCards];
            
            const selectedCounts = getCardCounts(selectedCards);
            const actualCounts = getCardCounts(actualCards);
            
            const selectedFourValue = Object.entries(selectedCounts).find(([value, count]) => count === 4)[0];
            const actualFourValue = Object.entries(actualCounts).find(([value, count]) => count === 4)[0];
            
            if (selectedFourValue !== actualFourValue) {
                const selectedFourName = getCardName({ value: parseInt(selectedFourValue), suit: '♠' });
                const actualFourName = getCardName({ value: parseInt(actualFourValue), suit: '♠' });
                return `${selectedPlayer.name} has Four of a Kind: ${selectedFourName}s, but ${actualWinner.name} has Four of a Kind: ${actualFourName}s. ${actualFourName}s beat ${selectedFourName}s.`;
            }
            
            // Same four of a kind, compare kicker
            const selectedKicker = selectedCards.find(card => card.value !== parseInt(selectedFourValue));
            const actualKicker = actualCards.find(card => card.value !== parseInt(actualFourValue));
            
            if (selectedKicker.value !== actualKicker.value) {
                const selectedKickerName = getCardName(selectedKicker);
                const actualKickerName = getCardName(actualKicker);
                return `Both players have Four of a Kind: ${getCardName({ value: parseInt(selectedFourValue), suit: '♠' })}s, but ${actualWinner.name} wins with ${actualKickerName} kicker vs ${selectedPlayer.name}'s ${selectedKickerName} kicker.`;
            }
            
            return `Both players have identical Four of a Kind and kickers. This should be a tie, but ${actualWinner.name} wins due to suit ranking.`;
        }
        
        // Helper function to get card name
        function getCardName(card) {
            switch (card.value) {
                case 14: return 'Ace';
                case 13: return 'King';
                case 12: return 'Queen';
                case 11: return 'Jack';
                default: return card.value.toString();
            }
        }
        
        function getStraightFlushComparison(selectedPlayer, actualWinner) {
            const selectedCards = [...selectedPlayer.holeCards, ...gameState.communityCards];
            const actualCards = [...actualWinner.holeCards, ...gameState.communityCards];
            
            // Find the highest straight flush for each player
            const selectedStraightFlush = findHighestStraight(selectedCards);
            const actualStraightFlush = findHighestStraight(actualCards);
            
            if (selectedStraightFlush[0].value !== actualStraightFlush[0].value) {
                const selectedTopCard = getCardName(selectedStraightFlush[0]);
                const actualTopCard = getCardName(actualStraightFlush[0]);
                return `Both players have a Straight Flush, but ${actualWinner.name} has ${actualTopCard} high vs ${selectedPlayer.name}'s ${selectedTopCard} high. ${actualTopCard} beats ${selectedTopCard}.`;
            }
            
            return `Both players have identical Straight Flush. This should be a tie, but ${actualWinner.name} wins due to suit ranking.`;
        }
        
        function getRoyalFlushComparison(selectedPlayer, actualWinner) {
            // Royal Flush is always the same (A, K, Q, J, 10 of same suit)
            // The only way to differentiate is by suit ranking
            return `Both players have Royal Flush, but ${actualWinner.name} wins due to suit ranking.`;
        }
        
        // Function to get detailed hand description for tooltips
        function getDetailedHandDescription(player) {
            if (gameState.currentStage === 'preflop' || gameState.currentStage === 'dealt') {
                // No tooltip before flop is dealt
                return '';
            }
            
            const handRank = getHandRankAtStage([...player.holeCards, ...gameState.communityCards], gameState.currentStage);
            let description = `${handRank.name}`;
            
            // Add specific details for certain hand types
            if (handRank.name === 'High Card') {
                const highCard = getHighCardName([...player.holeCards, ...gameState.communityCards]);
                description += `\n${highCard}`;
            } else if (handRank.name === 'One Pair') {
                const pairValue = findPairValue([...player.holeCards, ...gameState.communityCards]);
                const pairName = getCardName({ value: pairValue, suit: '♠' });
                description += `\nPair of ${pairName}s`;
            } else if (handRank.name === 'Two Pair') {
                description += '\nTwo Pairs';
            } else if (handRank.name === 'Three of a Kind') {
                description += '\nThree Matching Cards';
            } else if (handRank.name === 'Straight') {
                description += '\nFive Consecutive Cards';
            } else if (handRank.name === 'Flush') {
                description += '\nFive Same Suit';
            } else if (handRank.name === 'Full House') {
                description += '\nThree + Two Matching';
            } else if (handRank.name === 'Four of a Kind') {
                description += '\nFour Matching Cards';
            } else if (handRank.name === 'Straight Flush') {
                description += '\nStraight + Same Suit';
            }
            
            return description;
        }
        
        // New function to evaluate hand strength based on current game stage
        function evaluateHandStrengthAtStage(holeCards, communityCards, stage) {
            if (stage === 'preflop' || stage === 'dealt') {
                // Only hole cards are available
                return calculateHoleCardStrength(holeCards);
            } else if (stage === 'flop') {
                // Hole cards + 3 flop cards
                const availableCards = [...holeCards, ...communityCards.slice(0, 3)];
                const handRank = getHandRank(availableCards);
                return handRank.score;
            } else if (stage === 'turn') {
                // Hole cards + 4 community cards
                const availableCards = [...holeCards, ...communityCards.slice(0, 4)];
                const handRank = getHandRank(availableCards);
                return handRank.score;
            } else if (stage === 'river') {
                // Hole cards + all 5 community cards
                const availableCards = [...holeCards, ...communityCards];
                const handRank = getHandRank(availableCards);
                return handRank.score;
            }
            
            // Fallback to full evaluation
            return evaluateHandStrength(holeCards, communityCards);
        }
        
        // New function to get hand rank based on current game stage
        function getHandRankAtStage(cards, stage) {
            if (stage === 'preflop' || stage === 'dealt') {
                // Only hole cards - can only have high card
                const sorted = cards.sort((a, b) => b.value - a.value);
                return { name: 'High Card', score: sorted[0].value };
            } else if (stage === 'flop') {
                // Only first 3 community cards + hole cards
                const availableCards = cards.slice(0, 5); // 2 hole + 3 flop
                return getHandRank(availableCards);
            } else if (stage === 'turn') {
                // First 4 community cards + hole cards
                const availableCards = cards.slice(0, 6); // 2 hole + 4 community
                return getHandRank(availableCards);
            } else if (stage === 'river') {
                // All cards available
                return getHandRank(cards);
            }
            
            // Fallback to full evaluation
            return getHandRank(cards);
        }
        
        // Select winner
        function selectWinner(playerId) {
            gameState.selectedWinner = playerId;
            
            // Update button states
            document.querySelectorAll('.winner-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            document.querySelector(`[data-player="${playerId}"]`).classList.add('selected');
            
            // Automatically evaluate the winner after selection
            evaluateWinner();
        }
        
        // Evaluate winner
        function evaluateWinner() {
            if (gameState.selectedWinner === null) {
                showMessage('Please select a winner first!', 'error');
                return;
            }
            
            // Find actual winner(s) - handle ties properly
            let winners = findWinners();
            const selectedPlayer = gameState.players[gameState.selectedWinner];
            
            // Check if user's prediction was correct
            const isCorrect = winners.some(w => w.id === gameState.selectedWinner);
            
            // Build the main message
            let mainMessage = '';
            if (isCorrect) {
                if (winners.length === 1) {
                    mainMessage = `You correctly predicted that ${selectedPlayer.name} would win!`;
                } else {
                    mainMessage = `You correctly predicted that ${selectedPlayer.name} would win! (Tied with ${winners.length - 1} other player${winners.length > 2 ? 's' : ''})`;
                }
            } else {
                if (winners.length === 1) {
                    const actualPlayer = winners[0];
                    mainMessage = `${actualPlayer.name} actually won with a ${getHandRankAtStage([...actualPlayer.holeCards, ...gameState.communityCards], gameState.currentStage).name}.`;
                } else {
                    const winnerNames = winners.map(w => w.name).join(', ');
                    mainMessage = `There was a tie between ${winnerNames} with ${getHandRankAtStage([...winners[0].holeCards, ...gameState.communityCards], gameState.currentStage).name}.`;
                }
            }
            
            // Get hand information for explanations
            const selectedHand = getHandRankAtStage([...selectedPlayer.holeCards, ...gameState.communityCards], gameState.currentStage);
            
            // Enhanced explanation for high card wins
            let selectedExplanation = `${selectedPlayer.name} - ${selectedHand.name}`;
            if (selectedHand.name === 'High Card') {
                const selectedHighCard = getHighCardName([...selectedPlayer.holeCards, ...gameState.communityCards]);
                selectedExplanation += ` (${selectedHighCard})`;
            }
            
            let actualExplanation = '';
            if (winners.length === 1) {
                const actualHand = getHandRankAtStage([...winners[0].holeCards, ...gameState.communityCards], gameState.currentStage);
                actualExplanation = `${winners[0].name} - ${actualHand.name}`;
                if (actualHand.name === 'High Card') {
                    const actualHighCard = getHighCardName([...winners[0].holeCards, ...gameState.communityCards]);
                    actualExplanation += ` (${actualHighCard})`;
                }
            } else {
                // Handle ties
                const tieHand = getHandRankAtStage([...winners[0].holeCards, ...gameState.communityCards], gameState.currentStage);
                const winnerNames = winners.map(w => w.name).join(', ');
                actualExplanation = `TIE: ${winnerNames} - ${tieHand.name}`;
                
                if (tieHand.name === 'High Card') {
                    // Show all high cards in the tie
                    const highCards = winners.map(w => {
                        const highCard = getHighCardName([...w.holeCards, ...gameState.communityCards]);
                        return `${w.name}: ${highCard}`;
                    }).join(', ');
                    actualExplanation += ` (${highCards})`;
                }
            }
            
            // Add detailed explanation of why the winner won
            let detailedExplanation = '';
            if (winners.length === 1) {
                if (isCorrect) {
                    // User correctly predicted the winner - explain why they won
                    detailedExplanation = `🎯 ${selectedPlayer.name} won with ${getHandRankAtStage([...selectedPlayer.holeCards, ...gameState.communityCards], gameState.currentStage).name}!`;
                } else {
                    // User incorrectly predicted - explain why the selected player lost
                    detailedExplanation = getDetailedWinExplanation(selectedPlayer, winners[0]);
                }
            } else {
                // For ties, explain why they tied
                detailedExplanation = getTieExplanation(winners);
            }
            
            // Show everything in the unified overlay
            const overlayContent = `
                <h3>${isCorrect ? '🎉 Congratulations!' : '❌ Not Right!'}</h3>
                <div class="hand-explanation" style="background: ${isCorrect ? 'rgba(39, 174, 96, 0.2)' : 'rgba(231, 76, 60, 0.2)'}; border: 2px solid ${isCorrect ? 'rgba(39, 174, 96, 0.5)' : 'rgba(231, 76, 60, 0.5)'};">
                    ${mainMessage}
                </div>
                ${detailedExplanation ? `
                    <div class="hand-explanation">
                        <strong>📚 Why this happened:</strong><br>
                        ${detailedExplanation}
                    </div>
                ` : ''}
                <div class="hand-explanation">
                    <strong>Your selection:</strong> ${selectedExplanation}<br>
                    <strong>Actual result:</strong> ${actualExplanation}
                </div>
            `;
            showExplanationOverlay(overlayContent);
            
            // Reset selection
            gameState.selectedWinner = null;
            document.querySelectorAll('.winner-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
        }
        
        // Reset game
        function resetGame() {
            gameState.communityCards = [];
            gameState.currentStage = 'preflop';
            gameState.selectedWinner = null;
            
            // Recreate deck and players with current player count
            createDeck();
            shuffleDeck();
            setupPlayers(); // This will update the player count
            
            updateButtons();
            
            // Clear any messages
            document.getElementById('messageArea').innerHTML = '';
            
            // Clear community cards display
            document.getElementById('communityCards').innerHTML = '';
            
            // Reset player displays
            updateDisplay();
        }
        
        // Update display
        function updateDisplay() {
            // Update community cards
            const communityDiv = document.getElementById('communityCards');
            communityDiv.innerHTML = '';
            
            for (let i = 0; i < 5; i++) {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card';
                
                if (i < gameState.communityCards.length) {
                    const card = gameState.communityCards[i];
                    cardDiv.textContent = `${card.rank}${card.suit}`;
                    cardDiv.style.color = (card.suit === '♥' || card.suit === '♦') ? 'red' : 'black';
                    
                    // Add tooltip based on which stage this card was dealt
                    let stageInfo = '';
                    if (i < 3) {
                        stageInfo = 'Flop Card';
                    } else if (i === 3) {
                        stageInfo = 'Turn Card';
                    } else {
                        stageInfo = 'River Card';
                    }
                    cardDiv.title = `${stageInfo}: ${card.rank}${card.suit}`;
                } else {
                    cardDiv.className += ' hidden';
                    let stageInfo = '';
                    if (i === 3) {
                        stageInfo = 'Turn Card (Not Yet Dealt)';
                    } else if (i === 4) {
                        stageInfo = 'River Card (Not Yet Dealt)';
                    }
                    cardDiv.textContent = '';
                    cardDiv.title = stageInfo;
                }
                
                communityDiv.appendChild(cardDiv);
            }
            
            // Update players
            const playersGrid = document.getElementById('playersGrid');
            playersGrid.innerHTML = '';
            
            for (let player of gameState.players) {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player';
                
                let cardsHtml = '';
                if (player.holeCards.length > 0) {
                    // Get detailed hand description for tooltip
                    const handDescription = getDetailedHandDescription(player);
                    
                    for (let card of player.holeCards) {
                        const color = (card.suit === '♥' || card.suit === '♦') ? 'red' : 'black';
                        if (handDescription) {
                            cardsHtml += `<div class="card" style="color: ${color}" title="${handDescription}">${card.rank}${card.suit}</div>`;
                        } else {
                            cardsHtml += `<div class="card" style="color: ${color}">${card.rank}${card.suit}</div>`;
                        }
                    }
                } else {
                    cardsHtml = '<div class="card hidden" title="No cards dealt yet"></div><div class="card hidden" title="No cards dealt yet"></div>';
                }
                
                // Only show probability and winner button if cards are dealt
                let probabilityHtml = '';
                let winnerButtonHtml = '';
                
                if (player.holeCards.length > 0) {
                    probabilityHtml = `<div class="probability">Win Probability: ${player.probability}%</div>`;
                    winnerButtonHtml = `<button class="winner-btn" data-player="${player.id}" onclick="selectWinner(${player.id})">
                        Select as Winner
                    </button>`;
                }
                
                playerDiv.innerHTML = `
                    <h3>${player.name}</h3>
                    <div class="player-cards">${cardsHtml}</div>
                    ${probabilityHtml}
                    ${winnerButtonHtml}
                `;
                
                playersGrid.appendChild(playerDiv);
            }
        }
        
        // Update button states
        function updateButtons() {
            const dealBtn = document.getElementById('dealBtn');
            const flopBtn = document.getElementById('flopBtn');
            const turnBtn = document.getElementById('turnBtn');
            const riverBtn = document.getElementById('riverBtn');
            
            // Reset button is always enabled
            // Reset button doesn't need to be managed here
            
            if (gameState.currentStage === 'preflop') {
                // Initial state or after reset
                dealBtn.disabled = false;
                flopBtn.disabled = true;
                turnBtn.disabled = true;
                riverBtn.disabled = true;
            } else if (gameState.currentStage === 'dealt') {
                // After cards are dealt
                dealBtn.disabled = true;
                flopBtn.disabled = false;
                turnBtn.disabled = true;
                riverBtn.disabled = true;
            } else if (gameState.currentStage === 'flop') {
                // After flop is dealt
                dealBtn.disabled = true;
                flopBtn.disabled = true;
                turnBtn.disabled = false;
                riverBtn.disabled = true;
            } else if (gameState.currentStage === 'turn') {
                // After turn is dealt
                dealBtn.disabled = true;
                flopBtn.disabled = true;
                turnBtn.disabled = true;
                riverBtn.disabled = false;
            } else if (gameState.currentStage === 'river') {
                // After river is dealt
                dealBtn.disabled = true;
                flopBtn.disabled = true;
                turnBtn.disabled = true;
                riverBtn.disabled = true;
            }
        }
        
        // Show message
        function showMessage(text, type) {
            const messageArea = document.getElementById('messageArea');
            messageArea.innerHTML = `<div class="message ${type}" onmouseenter="pauseMessageTimer()" onmouseleave="resumeMessageTimer()">${text}</div>`;
            
            // Start the timer
            startMessageTimer();
        }
        
        // Timer variables for message display
        let messageTimer = null;
        let messageTimerPaused = false;
        
        // Start message timer
        function startMessageTimer() {
            if (messageTimer) {
                clearTimeout(messageTimer);
            }
            messageTimer = setTimeout(() => {
                if (!messageTimerPaused) {
                    document.getElementById('messageArea').innerHTML = '';
                }
            }, 8000);
        }
        
        // Pause message timer when hovering
        function pauseMessageTimer() {
            messageTimerPaused = true;
        }
        
        // Resume message timer when leaving
        function resumeMessageTimer() {
            messageTimerPaused = false;
            // Give user a moment to read, then start timer again
            setTimeout(() => {
                if (!messageTimerPaused) {
                    startMessageTimer();
                }
            }, 1000);
        }
        
        // Event listeners
        document.getElementById('playerCount').addEventListener('change', resetGame);
        
        // Initialize game
        initGame();
        
        // Instructions toggle function
        function toggleInstructions() {
            const panel = document.getElementById('instructionsPanel');
            const button = document.getElementById('instructionsBtn');
            
            if (panel.style.display === 'none') {
                // Show instructions
                panel.style.display = 'block';
                setTimeout(() => {
                    panel.classList.add('show');
                }, 10);
                button.textContent = '📖 Hide Instructions';
            } else {
                // Hide instructions
                panel.classList.remove('show');
                setTimeout(() => {
                    panel.style.display = 'none';
                }, 400);
                button.textContent = '📖 How to Play';
            }
        }

    </script>
</body>
</html>