<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poker Hand Evaluator - Learn Texas Hold'em Hand Rankings | Free Interactive Game</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Learn poker hand rankings with our interactive Texas Hold'em hand evaluator. Practice predicting winners and improve your poker skills with this free learning game. Perfect for beginners and intermediate players.">
    <meta name="keywords" content="poker hand evaluator, texas holdem, poker learning, hand rankings, poker practice, poker game, free poker tool, poker education, poker strategy, poker hands, royal flush, straight flush, four of a kind, full house, flush, straight, three of a kind, two pair, one pair, high card">
    <meta name="author" content="Poker Hand Evaluator">
    <meta name="robots" content="index, follow">
    <meta name="language" content="English">
    <meta name="revisit-after" content="7 days">
    
    <!-- Open Graph Meta Tags (Facebook, LinkedIn) -->
    <meta property="og:title" content="Poker Hand Evaluator - Learn Texas Hold'em Hand Rankings">
    <meta property="og:description" content="Interactive poker hand evaluator to learn and practice Texas Hold'em hand rankings. Free educational game for poker enthusiasts.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://masterpokerhands.com">
    <!-- <meta property="og:image" content="https://masterpokerhands.com/images/poker-hand-evaluator-preview.jpg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630"> -->
    <meta property="og:site_name" content="Poker Hand Evaluator">
    <meta property="og:locale" content="en_US">
    
    <!-- Twitter Card Meta Tags 
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Poker Hand Evaluator - Learn Texas Hold'em Hand Rankings">
    <meta name="twitter:description" content="Interactive poker hand evaluator to learn and practice Texas Hold'em hand rankings. Free educational game for poker enthusiasts.">
    <meta name="twitter:image" content="https://yourdomain.com/images/poker-hand-evaluator-preview.jpg">
    <meta name="twitter:site" content="@yourtwitterhandle">
    <meta name="twitter:creator" content="@yourtwitterhandle">
    -->
    
    <!-- Additional SEO Meta Tags -->
    <meta name="theme-color" content="#1a472a">
    <meta name="msapplication-TileColor" content="#1a472a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Poker Hand Evaluator">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://masterpokerhands.com">
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    
    <!-- Google Analytics (replace GA_MEASUREMENT_ID with your actual ID) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-VPB1FJ0L5S"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-VPB1FJ0L5S');
    </script>

    
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a472a, #2d5a3d);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
        }
        
        .header {
            text-align: center;
            margin-bottom: 25px;
            padding: 30px;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .header h1 {
            margin: 0 0 15px 0;
            font-size: 2.5em;
            font-weight: 300;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }
        
        .header p {
            margin: 0;
            font-size: 1.2em;
            opacity: 0.9;
            text-shadow: 0 1px 5px rgba(0,0,0,0.3);
        }
        
        /* Instructions Button */
        .instructions-btn {
            margin-top: 20px;
            padding: 12px 24px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .instructions-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            background: linear-gradient(135deg, #2980b9, #1f5f8b);
        }
        
        /* Instructions Panel */
        .instructions-panel {
            margin-top: 20px;
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 0;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.3);
            backdrop-filter: blur(10px);
            max-height: 0;
            transition: all 0.4s ease;
        }
        
        .instructions-panel.show {
            max-height: 80vh;
            padding: 25px;
            overflow-y: auto;
        }
        
        .instructions-content {
            color: #333;
            max-height: 70vh;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #888 #f1f1f1;
        }
        
        .instructions-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .instructions-content::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        .instructions-content::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        
        .instructions-content::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        .instructions-content h3 {
            margin: 0 0 20px 0;
            color: #2c3e50;
            font-size: 1.8em;
            text-align: center;
        }
        
        .instructions-content h4 {
            margin: 25px 0 10px 0;
            color: #34495e;
            font-size: 1.3em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }
        
        .instructions-content p {
            margin: 10px 0;
            line-height: 1.6;
            color: #555;
        }
        
        .instructions-content ol, .instructions-content ul {
            margin: 15px 0;
            padding-left: 25px;
        }
        
        .instructions-content li {
            margin: 8px 0;
            line-height: 1.5;
            color: #555;
        }
        
        .instructions-content strong {
            color: #2c3e50;
        }
        
        /* Close Button */
        .close-instructions-btn {
            display: block;
            margin: 25px auto 0 auto;
            padding: 10px 20px;
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .close-instructions-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255,255,255,0.08);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .controls .button-row {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        select {
            padding: 12px 18px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            background: rgba(255,255,255,0.9);
            color: #333;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        select:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        select:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.5);
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            transition: all 0.3s ease;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        button:hover::before {
            left: 100%;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
            background: linear-gradient(135deg, #45a049, #4CAF50);
        }
        
        button:active {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        button:disabled {
            background: linear-gradient(135deg, #666, #555);
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        #resetBtn {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
        }
        
        #resetBtn:hover {
            background: linear-gradient(135deg, #c0392b, #e74c3c);
            box-shadow: 0 8px 25px rgba(231, 76, 60, 0.5);
        }
        
        .game-area {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
        
        .community-cards {
            text-align: center;
            background: rgba(255,255,255,0.1);
            padding: 30px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .community-cards h3 {
            margin: 0 0 20px 0;
            color: #f39c12;
            font-size: 1.5em;
            text-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        .community-cards > div {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .card {
            display: inline-block;
            width: 65px;
            height: 85px;
            background: linear-gradient(135deg, #fff, #f8f9fa);
            color: #333;
            border-radius: 12px;
            margin: 0 8px;
            text-align: center;
            line-height: 85px;
            font-weight: bold;
            font-size: 18px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3), 0 2px 4px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            border: 1px solid rgba(0,0,0,0.1);
        }
        
        .card:hover {
            transform: translateY(-8px) scale(1.05);
            box-shadow: 0 12px 30px rgba(0,0,0,0.4), 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .card.hidden {
            background: url('images/pokercardbackside.png') center/contain;
            background-repeat: no-repeat;
            color: transparent;
            border: 1px solid rgba(255,255,255,0.1);
            line-height: normal;
            border-radius: 12px;
            overflow: hidden;
            background-color: #2c3e50;
        }
        
        .card.hidden:hover {
            transform: translateY(-8px) scale(1.05);
            box-shadow: 0 12px 30px rgba(0,0,0,0.4), 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .players-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 25px;
        }
        
        .player {
            background: rgba(255,255,255,0.1);
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }
        
        .player:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0,0,0,0.3);
        }
        
        .player h3 {
            margin: 0 0 20px 0;
            color: #f39c12;
            font-size: 1.4em;
            text-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        .player-cards {
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
        }
        
        .probability {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #2ecc71;
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        .winner-btn {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
        }
        
        .winner-btn:hover {
            background: linear-gradient(135deg, #c0392b, #e74c3c);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(231, 76, 60, 0.5);
        }
        
        .winner-btn.selected {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.4);
        }
        
        .winner-btn.selected:hover {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            box-shadow: 0 8px 25px rgba(39, 174, 96, 0.5);
        }
        
        .message {
            text-align: center;
            padding: 25px;
            border-radius: 15px;
            margin: 25px 0;
            font-size: 18px;
            transition: all 0.3s ease;
            cursor: default;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .message:hover {
            transform: scale(1.02);
            box-shadow: 0 12px 40px rgba(0,0,0,0.3);
        }
        
        .success {
            background: rgba(39, 174, 96, 0.2);
            border: 2px solid rgba(39, 174, 96, 0.5);
        }
        
        .error {
            background: rgba(231, 76, 60, 0.2);
            border: 2px solid rgba(231, 76, 60, 0.5);
        }
        
        .hand-explanation {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
            font-size: 14px;
            transition: all 0.3s ease;
            cursor: default;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .hand-explanation:hover {
            background: rgba(255,255,255,0.15);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        /* Fixed Overlay for Explanations */
        .explanation-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .explanation-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        
        .explanation-content {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 40px;
            border-radius: 20px;
            width: 600px;
            min-height: 400px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.1);
            transform: scale(0.9) translateY(20px);
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            flex-direction: column;
        }
        
        .explanation-overlay.show .explanation-content {
            transform: scale(1) translateY(0);
        }
        
        .explanation-content h3 {
            margin: 0 0 20px 0;
            color: #f39c12;
            font-size: 1.8em;
            text-align: center;
            text-shadow: 0 2px 8px rgba(0,0,0,0.3);
            flex-shrink: 0;
        }
        
        .explanation-content .hand-explanation {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            font-size: 16px;
            line-height: 1.6;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            flex: 1;
        }
        
        .close-explanation-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .close-explanation-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .static-message-line {
            text-align: center;
            padding: 5px;
            margin: 8px 0;
            font-size: 16px;
            color: white;
            min-height: 20px;
            width: 100%;
            /* Always visible line - never disappears */
        }
        
        .static-message-line:empty::after {
            content: '';
            display: block;
            height: 20px;
        }
        
        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 20px;
                margin-bottom: 20px;
            }
            
            .header h1 {
                font-size: 2em;
                margin-bottom: 10px;
            }
            
            .header p {
                font-size: 1em;
            }
            
            .instructions-btn {
                padding: 10px 20px;
                font-size: 14px;
            }
            
            .controls {
                padding: 15px;
                margin-bottom: 20px;
            }
            
            .controls .button-row {
                flex-direction: column;
                gap: 10px;
            }
            
            select, button {
                min-height: 44px;
                font-size: 16px;
                width: 100%;
                max-width: 300px;
            }
            
            .card {
                width: 80px;
                height: 100px;
                font-size: 20px;
                line-height: 100px;
                margin: 0 4px;
            }
            
            .card.hidden {
                line-height: normal;
            }
            
            .community-cards {
                padding: 20px;
            }
            
            .community-cards h3 {
                font-size: 1.3em;
                margin-bottom: 15px;
            }
            
            .players-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .player {
                padding: 15px;
            }
            
            .player h3 {
                font-size: 1.2em;
                margin-bottom: 15px;
            }
            
            .probability {
                font-size: 16px;
                margin-bottom: 15px;
            }
            
            .winner-btn {
                padding: 10px 20px;
                font-size: 14px;
                min-height: 44px;
            }
            
            .message {
                padding: 20px;
                font-size: 16px;
                margin: 15px 0;
            }
            
            .hand-explanation {
                padding: 15px;
                font-size: 13px;
                margin-top: 15px;
            }
            
            .explanation-content {
                width: 95%;
                padding: 25px;
                min-height: 300px;
            }
            
            .explanation-content h3 {
                font-size: 1.5em;
                margin-bottom: 15px;
            }
        }
        
        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            
            .header {
                padding: 15px;
                border-radius: 15px;
            }
            
            .header h1 {
                font-size: 1.6em;
            }
            
            .header p {
                font-size: 0.9em;
            }
            
            .controls {
                padding: 10px;
            }
            
            .card {
                width: 70px;
                height: 90px;
                font-size: 18px;
                line-height: 90px;
                margin: 0 2px;
            }
            
            .card.hidden {
                line-height: normal;
            }
            
            .community-cards {
                padding: 15px;
            }
            
            .community-cards h3 {
                font-size: 1.2em;
            }
            
            .player {
                padding: 12px;
            }
            
            .player h3 {
                font-size: 1.1em;
            }
            
            .probability {
                font-size: 15px;
            }
            
            .winner-btn {
                padding: 8px 16px;
                font-size: 13px;
            }
            
            .message {
                padding: 15px;
                font-size: 15px;
            }
            
            .hand-explanation {
                padding: 12px;
                font-size: 12px;
            }
            
            .explanation-content {
                width: 98%;
                padding: 20px;
                min-height: 250px;
            }
            
            .explanation-content h3 {
                font-size: 1.3em;
            }
        }
        
        /* Landscape orientation for mobile */
        @media (max-width: 768px) and (orientation: landscape) {
            .header h1 {
                font-size: 1.8em;
            }
            
            .controls .button-row {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            select, button {
                width: auto;
                min-width: 120px;
            }
            
            .card {
                width: 75px;
                height: 95px;
                line-height: 95px;
            }
            
            .card.hidden {
                line-height: normal;
            }
        }
        
        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .card:hover {
                transform: none;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3), 0 2px 4px rgba(0,0,0,0.1);
            }
            
            .card.hidden:hover {
                transform: none;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3), 0 2px 4px rgba(0,0,0,0.1);
            }
            
            .player:hover {
                transform: none;
                box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            }
            
            .message:hover {
                transform: none;
                box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            }
            
            .hand-explanation:hover {
                transform: none;
                box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            }
        }
    </style>
</head>
<body>
    <div class="container">
                <div class="header">
            <h1>🎰 Poker Hand Evaluator - Learning Game</h1>
            <p>Learn to evaluate poker hands by predicting winners at each stage</p>
            
            <!-- Instructions Button -->
            <button id="instructionsBtn" class="instructions-btn" onclick="toggleInstructions()">
                📖 How to Play
            </button>
            
            <!-- Instructions Panel -->
            <div id="instructionsPanel" class="instructions-panel" style="display: none;">
                <div class="instructions-content">
                    <h3>🎯 Game Instructions</h3>
                    
                    <h4>🎮 Objective</h4>
                    <p>Learn to evaluate poker hands by predicting winners at each stage of Texas Hold'em.</p>
                    
                    <h4>📋 How to Play</h4>
                    <ol>
                        <li><strong>Select Players:</strong> Choose 2-9 players using the dropdown</li>
                        <li><strong>Deal Cards:</strong> Click "Deal Cards" to give each player 2 hole cards</li>
                        <li><strong>Evaluate Preflop:</strong> See win probabilities and select who you think will win</li>
                        <li><strong>Deal Flop:</strong> Click "Deal Flop" to reveal 3 community cards</li>
                        <li><strong>Re-evaluate:</strong> Probabilities update - select your winner again</li>
                        <li><strong>Deal Turn:</strong> Click "Deal Turn" to reveal the 4th community card</li>
                        <li><strong>Final Evaluation:</strong> Select winner based on 6 visible cards</li>
                        <li><strong>Deal River:</strong> Click "Deal River" to reveal the final community card</li>
                        <li><strong>Final Winner:</strong> Select the ultimate winner with all 7 cards visible</li>
                    </ol>
                    
                    <h4>🏆 Hand Rankings (Best to Worst)</h4>
                    <ol>
                        <li><strong>Royal Flush:</strong> A, K, Q, J, 10 of same suit</li>
                        <li><strong>Straight Flush:</strong> 5 consecutive cards of same suit</li>
                        <li><strong>Four of a Kind:</strong> 4 cards of same rank</li>
                        <li><strong>Full House:</strong> 3 of a kind + 1 pair</li>
                        <li><strong>Flush:</strong> 5 cards of same suit</li>
                        <li><strong>Straight:</strong> 5 consecutive cards</li>
                        <li><strong>Three of a Kind:</strong> 3 cards of same rank</li>
                        <li><strong>Two Pair:</strong> 2 different pairs</li>
                        <li><strong>One Pair:</strong> 2 cards of same rank</li>
                        <li><strong>High Card:</strong> Highest card wins</li>
                    </ol>
                    
                    <h4>💡 Learning Tips</h4>
                    <ul>
                        <li>Start with 2-3 players to learn the basics</li>
                        <li>Pay attention to how probabilities change at each stage</li>
                        <li>Use the tooltips on cards to see hand descriptions</li>
                        <li>Learn from the detailed explanations after each prediction</li>
                        <li>Practice with different player counts to see various scenarios</li>
                    </ul>
                    
                    <button class="close-instructions-btn" onclick="toggleInstructions()">✕ Close</button>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div id="messageArea" class="static-message-line"></div>
            
            <div class="button-row">
                <select id="playerCount">
                    <option value="2">2 Players</option>
                    <option value="3">3 Players</option>
                    <option value="4">4 Players</option>
                    <option value="5">5 Players</option>
                    <option value="6">6 Players</option>
                    <option value="7">7 Players</option>
                    <option value="8">8 Players</option>
                    <option value="9">9 Players</option>
                </select>
                
                <button id="dealBtn" onclick="dealCards()">Deal Cards</button>
                <button id="flopBtn" onclick="dealFlop()" disabled>Deal Flop</button>
                <button id="turnBtn" onclick="dealTurn()" disabled>Deal Turn</button>
                <button id="riverBtn" onclick="dealRiver()" disabled>Deal River</button>
                <button id="resetBtn" onclick="resetGame()" style="background: #e74c3c;">Reset Game</button>
            </div>
        </div>
        
        <div class="game-area">
            <div class="community-cards">
                <h3>Community Cards</h3>
                <div id="communityCards"></div>
            </div>
            
            <div id="playersGrid" class="players-grid"></div>
        </div>
    
    <!-- Fixed Explanation Overlay -->
    <div id="explanationOverlay" class="explanation-overlay">
        <div class="explanation-content">
            <button class="close-explanation-btn" onclick="closeExplanation()">Close</button>
            <div id="explanationContent"></div>
        </div>
    </div>
</div>

    <script>
        // Game state
        let gameState = {
            players: [],
            communityCards: [],
            deck: [],
            currentStage: 'preflop', // preflop, flop, turn, river
            selectedWinner: null
        };
        
        // Card suits and ranks
        const suits = ['♠', '♥', '♦', '♣'];
        const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        
        // Add this function after your existing Google Analytics code
        function trackEvent(eventName, eventCategory, eventLabel, eventValue) {
            if (typeof gtag !== 'undefined') {
                gtag('event', eventName, {
                    event_category: eventCategory,
                    event_label: eventLabel,
                    value: eventValue
                });
            }
        }
        
        // Initialize game
        function initGame() {
            createDeck();
            shuffleDeck();
            setupPlayers();
            updateDisplay();
        }
        
        // Create and shuffle deck
        function createDeck() {
            gameState.deck = [];
            for (let suit of suits) {
                for (let rank of ranks) {
                    gameState.deck.push({ rank, suit, value: getCardValue(rank) });
                }
            }
        }
        
        function shuffleDeck() {
            for (let i = gameState.deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [gameState.deck[i], gameState.deck[j]] = [gameState.deck[j], gameState.deck[i]];
            }
        }
        
        function getCardValue(rank) {
            if (rank === 'A') return 14;
            if (rank === 'K') return 13;
            if (rank === 'Q') return 12;
            if (rank === 'J') return 11;
            return parseInt(rank);
        }
        
        // Setup players
        function setupPlayers() {
            const playerCount = parseInt(document.getElementById('playerCount').value);
            gameState.players = [];
            
            for (let i = 0; i < playerCount; i++) {
                gameState.players.push({
                    id: i,
                    name: `Player ${i + 1}`,
                    holeCards: [],
                    probability: 0,
                    isWinner: false
                });
            }
        }
        
        // Deal initial cards
        function dealCards() {
            if (gameState.currentStage !== 'preflop') {
                resetGame();
            }
            
            // Track the deal cards event
            trackEvent('deal_cards', 'game_action', 'initial_deal', gameState.players.length);
            
            // Reset explanation overlay
            const overlay = document.getElementById('explanationOverlay');
            if (overlay) {
                overlay.classList.remove('show');
                const contentDiv = document.getElementById('explanationContent');
                if (contentDiv) {
                    contentDiv.innerHTML = '';
                }
            }
            
            // Deal 2 cards to each player
            for (let player of gameState.players) {
                player.holeCards = [gameState.deck.pop(), gameState.deck.pop()];
            }
            
            gameState.currentStage = 'dealt';
            calculateProbabilities();
            updateDisplay();
            updateButtons();
            
            showMessage('Cards dealt! Select who you think will win, then deal the flop.', 'info');
        }
        
        // Deal flop
        function dealFlop() {
            if (gameState.currentStage !== 'dealt') return;
            
            // Track the flop event
            trackEvent('deal_flop', 'game_action', 'flop_dealt', gameState.players.length);
            
            // Reset explanation overlay
            const overlay = document.getElementById('explanationOverlay');
            if (overlay) {
                overlay.classList.remove('show');
                const contentDiv = document.getElementById('explanationContent');
                if (contentDiv) {
                    contentDiv.innerHTML = '';
                }
            }
            
            gameState.communityCards = [
                gameState.deck.pop(),
                gameState.deck.pop(),
                gameState.deck.pop()
            ];
            
            gameState.currentStage = 'flop';
            calculateProbabilities();
            updateDisplay();
            updateButtons();
            
            showMessage('Flop dealt! Select who you think will win, then deal the turn.', 'info');
        }
        
        // Deal turn
        function dealTurn() {
            if (gameState.currentStage !== 'flop') return;
            
            // Track the turn event
            trackEvent('deal_turn', 'game_action', 'turn_dealt', gameState.players.length);
            
            // Reset explanation overlay
            const overlay = document.getElementById('explanationOverlay');
            if (overlay) {
                overlay.classList.remove('show');
                const contentDiv = document.getElementById('explanationContent');
                if (contentDiv) {
                    contentDiv.innerHTML = '';
                }
            }
            
            gameState.communityCards.push(gameState.deck.pop());
            gameState.currentStage = 'turn';
            calculateProbabilities();
            updateDisplay();
            updateButtons();
            
            showMessage('Turn dealt! Select who you think will win, then deal the river.', 'info');
        }
        
        // Deal river
        function dealRiver() {
            if (gameState.currentStage !== 'turn') return;
            
            // Track the river event
            trackEvent('deal_river', 'game_action', 'river_dealt', gameState.players.length);
            
            // Reset explanation overlay
            const overlay = document.getElementById('explanationOverlay');
            if (overlay) {
                overlay.classList.remove('show');
                const contentDiv = document.getElementById('explanationContent');
                if (contentDiv) {
                    contentDiv.innerHTML = '';
                }
            }
            
            gameState.communityCards.push(gameState.deck.pop());
            gameState.currentStage = 'river';
            calculateProbabilities();
            updateDisplay();
            updateButtons();
            
            showMessage('River dealt! Select who you think will win, then evaluate!', 'info');
        }
        
        // Calculate winning probabilities
        function calculateProbabilities() {
            // Don't calculate probabilities if no cards are dealt yet
            if (gameState.currentStage === 'preflop') {
                for (let player of gameState.players) {
                    player.probability = 0;
                }
                return;
            }
            
            // Calculate probabilities based on current game stage
            for (let player of gameState.players) {
                let probability = 0;
                
                if (gameState.currentStage === 'dealt') {
                    // Preflop: based on hole card strength (0-100 scale)
                    probability = calculateHoleCardStrength(player.holeCards);
                } else {
                    // Post-flop: based on hand ranking and potential
                    probability = calculatePostFlopProbability(player.holeCards, gameState.communityCards, gameState.currentStage);
                }
                
                player.probability = Math.round(probability);
            }
            

            
            // For river stage, use actual hand strength to determine clear winner
            if (gameState.currentStage === 'river') {
                // Find the best hand score
                const handScores = gameState.players.map(player => {
                    const allCards = [...player.holeCards, ...gameState.communityCards];
                    const handRank = getHandRankAtStage(allCards, gameState.currentStage);
                    return { player, score: handRank.score, handType: handRank.name };
                });
                
                // Sort by score (highest first)
                handScores.sort((a, b) => b.score - a.score);
                
                // Check if there's a clear winner or tie
                const bestScore = handScores[0].score;
                const tiedPlayers = handScores.filter(h => h.score === bestScore);
                
                if (tiedPlayers.length === 1) {
                    // Clear winner - give them 95%, others share 5%
                    for (let player of gameState.players) {
                        if (player === tiedPlayers[0].player) {
                            player.probability = 95;
                        } else {
                            player.probability = Math.round(5 / (gameState.players.length - 1));
                        }
                    }
                } else {
                    // Potential tie - use tie-breaking logic to find actual winner(s)
                    const winners = findWinners();
                    
                    if (winners.length === 1) {
                        // Tie-breaking resolved to single winner
                        for (let i = 0; i < gameState.players.length; i++) {
                            if (i === winners[0].id) {
                                gameState.players[i].probability = 95;
                            } else {
                                gameState.players[i].probability = Math.round(5 / (gameState.players.length - 1));
                            }
                        }
                    } else {
                        // True tie - distribute evenly among winners
                        const tieProb = Math.round(100 / winners.length);
                        for (let i = 0; i < gameState.players.length; i++) {
                            if (winners.some(w => w.id === i)) {
                                gameState.players[i].probability = tieProb;
                            } else {
                                gameState.players[i].probability = 0;
                            }
                        }
                    }
                }
            } else {
                // For other stages, use normal normalization
                const total = gameState.players.reduce((sum, p) => sum + p.probability, 0);
                if (total > 0) {
                    for (let player of gameState.players) {
                        player.probability = Math.round((player.probability / total) * 100);
                    }
                } else {
                    // If all probabilities are 0, distribute evenly
                    const equalProb = Math.round(100 / gameState.players.length);
                    for (let player of gameState.players) {
                        player.probability = equalProb;
                    }
                }
            }
            
            // Ensure at least one player has a non-zero probability
            const maxProb = Math.max(...gameState.players.map(p => p.probability));
            if (maxProb === 0) {
                gameState.players[0].probability = 100;
            }
        }
        
        // Calculate probability for post-flop hands
        function calculatePostFlopProbability(holeCards, communityCards, stage) {
            const handRank = getHandRankAtStage([...holeCards, ...communityCards], stage);
            let probability = 0;
            
            // Base probability from hand strength
            switch (handRank.name) {
                case 'Royal Flush':
                case 'Straight Flush':
                    probability = 95;
                    break;
                case 'Four of a Kind':
                    probability = 90;
                    break;
                case 'Full House':
                    probability = 85;
                    break;
                case 'Flush':
                    probability = 80;
                    break;
                case 'Straight':
                    probability = 75;
                    break;
                case 'Three of a Kind':
                    probability = 70;
                    break;
                case 'Two Pair':
                    probability = 65;
                    break;
                case 'One Pair':
                    probability = 60;
                    break;
                case 'High Card':
                    probability = 40;
                    break;
            }
            
            // Adjust based on remaining cards to be dealt
            if (stage === 'flop') {
                // 2 more cards coming - high potential for improvement
                // Add potential bonus based on hand type
                if (handRank.name === 'High Card') {
                    probability += 15; // High potential to improve
                } else if (handRank.name === 'One Pair') {
                    probability += 10; // Moderate potential
                } else if (handRank.name === 'Two Pair') {
                    probability += 5; // Low potential
                }
            } else if (stage === 'turn') {
                // 1 more card coming - moderate potential
                if (handRank.name === 'High Card') {
                    probability += 8; // Moderate potential
                } else if (handRank.name === 'One Pair') {
                    probability += 5; // Low potential
                }
            } else if (stage === 'river') {
                // Final hand - no more improvement possible
                // For river stage, use hand score directly for more accurate probabilities
                const score = handRank.score;
                if (score >= 800) probability = 99; // Royal Flush
                else if (score >= 700) probability = 98; // Four of a Kind
                else if (score >= 600) probability = 97; // Full House
                else if (score >= 500) probability = 95; // Flush
                else if (score >= 400) probability = 92; // Straight
                else if (score >= 300) probability = 88; // Three of a Kind
                else if (score >= 200) probability = 80 + (score - 200) / 5; // Two Pair (80 + score bonus, more sensitive)
                else if (score >= 100) probability = 75 + (score - 100) / 10; // One Pair (75 + score bonus)
                else probability = 60 + score; // High Card (60 + card value)
            }
            
            // Ensure probability stays within bounds
            return Math.min(100, Math.max(0, probability));
        }
        
        function calculateHoleCardStrength(holeCards) {
            // Return 0 if no cards are dealt
            if (!holeCards || holeCards.length < 2) {
                return 0;
            }
            
            let strength = 0;
            
            // High card value (0-14 scale, convert to 0-50) - PRIORITY
            strength += Math.max(holeCards[0].value, holeCards[1].value) * 3.5;
            
            // Second high card value (0-14 scale, convert to 0-25)
            strength += Math.min(holeCards[0].value, holeCards[1].value) * 1.8;
            
            // Pairs (biggest boost)
            if (holeCards[0].value === holeCards[1].value) {
                strength += 50;
            }
            
            // Suited cards (smaller bonus)
            if (holeCards[0].suit === holeCards[1].suit) {
                strength += 8;
            }
            
            // Connected cards (smaller bonus)
            const diff = Math.abs(holeCards[0].value - holeCards[1].value);
            if (diff === 1) strength += 12; // Connected
            if (diff === 2) strength += 8;  // 1 gap
            if (diff === 3) strength += 5;  // 2 gap
            
            // Ensure strength stays within 0-100 range
            return Math.min(100, Math.max(0, strength));
        }
        
        function evaluateHandStrength(holeCards, communityCards) {
            const allCards = [...holeCards, ...communityCards];
            const handRank = getHandRank(allCards);
            return handRank.score;
        }
        
        function getHandRank(cards) {
            // Find the best 5-card hand from the available cards
            return findBestFiveCardHand(cards);
        }
        
        function findBestFiveCardHand(cards) {
            // If we have exactly 5 cards, evaluate them directly
            if (cards.length === 5) {
                return evaluateFiveCards(cards);
            }
            
            // If we have more than 5 cards, find the best 5-card combination
            if (cards.length > 5) {
                const combinations = getCombinations(cards, 5);
                let bestHand = { name: 'High Card', score: 0 };
                
                for (let combination of combinations) {
                    const hand = evaluateFiveCards(combination);
                    if (hand.score > bestHand.score) {
                        bestHand = hand;
                    }
                }
                
                return bestHand;
            }
            
            // If we have fewer than 5 cards, evaluate what we have
            return evaluateFiveCards(cards);
        }
        
        function evaluateFiveCards(cards) {
            // Enhanced hand ranking with pair values for exactly 5 cards
            const sorted = cards.sort((a, b) => b.value - a.value);
            const counts = {};
            const suits = {};
            
            for (let card of cards) {
                counts[card.value] = (counts[card.value] || 0) + 1;
                suits[card.suit] = (suits[card.suit] || 0) + 1;
            }
            
            const pairs = Object.values(counts).filter(c => c >= 2);
            const isFlush = Object.values(suits).some(c => c >= 5);
            const isStraight = checkStraight(sorted);
            
            if (isFlush && isStraight) return { name: 'Straight Flush', score: 800 };
            if (pairs.includes(4)) return { name: 'Four of a Kind', score: 700 };
            if (pairs.includes(3) && pairs.includes(2)) return { name: 'Full House', score: 600 };
            if (isFlush) return { name: 'Flush', score: 500 };
            if (isStraight) return { name: 'Straight', score: 400 };
            if (pairs.includes(3)) return { name: 'Three of a Kind', score: 300 };
            // Check for Two Pair - count how many values have exactly 2 cards
            const pairValues = Object.entries(counts)
                .filter(([value, count]) => count === 2)
                .map(([value, count]) => parseInt(value))
                .sort((a, b) => b - a); // Sort pairs in descending order
            
            if (pairValues.length >= 2) {
                // Two Pair - include the values of the pairs in the score
                const kicker = sorted.find(card => card.value !== pairValues[0] && card.value !== pairValues[1]);
                const score = 200 + (pairValues[0] * 10) + pairValues[1] + (kicker ? kicker.value : 0);
                console.log(`Two Pair detected: ${pairValues[0]}s and ${pairValues[1]}s with ${kicker ? getCardName(kicker) : 'no'} kicker`);
                return { name: 'Two Pair', score: score };
            }
            if (pairs.includes(2)) {
                // One Pair - include the pair value and kickers in the score
                const pairValue = Object.entries(counts).find(([value, count]) => count === 2)[0];
                const kickers = sorted.filter(card => card.value !== parseInt(pairValue)).slice(0, 3);
                const kickerSum = kickers.reduce((sum, card) => sum + card.value, 0);
                const score = 100 + (parseInt(pairValue) * 10) + kickerSum;
                console.log(`One Pair detected: ${getCardName({ value: parseInt(pairValue), suit: '♠' })}s with kickers: ${kickers.map(k => getCardName(k)).join(', ')}`);
                return { name: 'One Pair', score: score };
            }
            
            return { name: 'High Card', score: sorted[0].value };
        }
        
        // Helper function to get all combinations of n cards from a set of cards
        function getCombinations(cards, n) {
            if (n === 0) return [[]];
            if (cards.length === 0) return [];
            
            const combinations = [];
            
            for (let i = 0; i <= cards.length - n; i++) {
                const current = cards[i];
                const remaining = cards.slice(i + 1);
                const subCombinations = getCombinations(remaining, n - 1);
                
                for (let subCombination of subCombinations) {
                    combinations.push([current, ...subCombination]);
                }
            }
            
            return combinations;
        }
        
        function checkStraight(cards) {
            // Sort cards in descending order
            const sorted = cards.sort((a, b) => b.value - a.value);
            
            // Check for 5 consecutive cards
            for (let i = 0; i <= sorted.length - 5; i++) {
                let consecutive = true;
                for (let j = 0; j < 4; j++) {
                    if (sorted[i + j].value - sorted[i + j + 1].value !== 1) {
                        consecutive = false;
                        break;
                    }
                }
                if (consecutive) {
                    return true;
                }
            }
            return false;
        }
        
        // Helper function to get high card name
        function getHighCardName(cards) {
            const sorted = cards.sort((a, b) => b.value - a.value);
            const highCard = sorted[0];
            
            // Convert numeric values to card names
            let cardName = '';
            switch (highCard.value) {
                case 14: cardName = 'Ace'; break;
                case 13: cardName = 'King'; break;
                case 12: cardName = 'Queen'; break;
                case 11: cardName = 'Jack'; break;
                default: cardName = highCard.value.toString();
            }
            
            return `${cardName} of ${getSuitName(highCard.suit)}`;
        }
        
        // Helper function to get suit name
        function getSuitName(suit) {
            switch (suit) {
                case '♠': return 'Spades';
                case '♥': return 'Hearts';
                case '♦': return 'Diamonds';
                case '♣': return 'Clubs';
                default: return suit;
            }
        }
        
        // New function to find all winners (handles ties)
        function findWinners() {
            console.log('findWinners called, currentStage:', gameState.currentStage);
            console.log('Players:', gameState.players);
            console.log('Community cards:', gameState.communityCards);
            
            let bestScore = -1;
            let winners = [];
            
            // First pass: find the best score based on current game stage
            for (let i = 0; i < gameState.players.length; i++) {
                const score = evaluateHandStrengthAtStage(gameState.players[i].holeCards, gameState.communityCards, gameState.currentStage);
                console.log(`Player ${i} score:`, score);
                if (score > bestScore) {
                    bestScore = score;
                }
            }
            
            console.log('Best score found:', bestScore);
            
            // Second pass: find all players with the best score
            for (let i = 0; i < gameState.players.length; i++) {
                const score = evaluateHandStrengthAtStage(gameState.players[i].holeCards, gameState.communityCards, gameState.currentStage);
                if (score === bestScore) {
                    winners.push({
                        id: i,
                        name: gameState.players[i].name,
                        holeCards: gameState.players[i].holeCards,
                        score: score
                    });
                }
            }
            
            console.log('Winners before tie-breaking:', winners);
            
            // If there are ties, try to break them with kickers
            if (winners.length > 1) {
                console.log('Attempting to break ties...');
                const winnersBeforeTieBreak = [...winners];
                winners = breakTies(winners);
                console.log('Winners after tie-breaking:', winners);
                
                // If tie-breaking didn't resolve the tie, keep the original winners
                if (winners.length === 1 && winnersBeforeTieBreak.length > 1) {
                    console.log('Tie-breaking resolved to single winner');
                } else if (winners.length > 1) {
                    console.log('Tie-breaking still shows multiple winners - true tie detected');
                }
            }
            
            console.log('Final winners:', winners);
            return winners;
        }
        
        // New function to break ties using kickers
        function breakTies(winners) {
            if (winners.length <= 1) return winners;
            
            // Get the hand type for all winners based on current stage
            const handType = getHandRankAtStage([...winners[0].holeCards, ...gameState.communityCards], gameState.currentStage).name;
            
            // For different hand types, we need different tie-breaking logic
            if (handType === 'High Card') {
                return breakHighCardTie(winners);
            } else if (handType === 'One Pair') {
                return breakOnePairTie(winners);
            } else if (handType === 'Two Pair') {
                return breakTwoPairTie(winners);
            } else if (handType === 'Three of a Kind') {
                return breakThreeOfAKindTie(winners);
            } else if (handType === 'Straight') {
                return breakStraightTie(winners);
            } else if (handType === 'Flush') {
                return breakFlushTie(winners);
            } else if (handType === 'Full House') {
                return breakFullHouseTie(winners);
            } else if (handType === 'Four of a Kind') {
                return breakFourOfAKindTie(winners);
            } else if (handType === 'Straight Flush') {
                return breakStraightTie(winners); // Same as straight
            }
            
            // For hands that can't tie (like Royal Flush), return all winners
            return winners;
        }
        
        // Helper function to break high card ties
        function breakHighCardTie(winners) {
            // Sort winners by their 5 highest cards (kickers)
            winners.sort((a, b) => {
                const aCards = [...a.holeCards, ...gameState.communityCards].sort((x, y) => y.value - x.value).slice(0, 5);
                const bCards = [...b.holeCards, ...gameState.communityCards].sort((x, y) => y.value - x.value).slice(0, 5);
                
                for (let i = 0; i < 5; i++) {
                    if (aCards[i].value !== bCards[i].value) {
                        return bCards[i].value - aCards[i].value;
                    }
                }
                return 0; // Complete tie
            });
            
            // Check if there's a true tie (all 5 cards are the same)
            if (winners.length > 1) {
                const firstCards = [...winners[0].holeCards, ...gameState.communityCards].sort((x, y) => y.value - x.value).slice(0, 5);
                const secondCards = [...winners[1].holeCards, ...gameState.communityCards].sort((x, y) => y.value - x.value).slice(0, 5);
                
                let isTrueTie = true;
                for (let i = 0; i < 5; i++) {
                    if (firstCards[i].value !== secondCards[i].value) {
                        isTrueTie = false;
                        break;
                    }
                }
                
                if (isTrueTie) {
                    // True tie - return all winners
                    return winners;
                }
            }
            
            return [winners[0]];
        }
        
        // Helper function to break one pair ties
        function breakOnePairTie(winners) {
            // Sort by pair value first, then by kickers
            winners.sort((a, b) => {
                const aPair = findPairValue([...a.holeCards, ...gameState.communityCards]);
                const bPair = findPairValue([...b.holeCards, ...gameState.communityCards]);
                
                if (aPair !== bPair) {
                    return bPair - aPair;
                }
                
                // Same pair, check kickers
                const aKickers = getKickers([...a.holeCards, ...gameState.communityCards], aPair);
                const bKickers = getKickers([...b.holeCards, ...gameState.communityCards], bPair);
                
                for (let i = 0; i < 3; i++) {
                    if (aKickers[i] !== bKickers[i]) {
                        return bKickers[i] - aKickers[i];
                    }
                }
                return 0;
            });
            
            // Check if there's a true tie (same pair and all kickers)
            if (winners.length > 1) {
                const firstPair = findPairValue([...winners[0].holeCards, ...gameState.communityCards]);
                const secondPair = findPairValue([...winners[1].holeCards, ...gameState.communityCards]);
                const firstKickers = getKickers([...winners[0].holeCards, ...gameState.communityCards], firstPair);
                const secondKickers = getKickers([...winners[1].holeCards, ...gameState.communityCards], secondPair);
                
                if (firstPair === secondPair && 
                    firstKickers[0] === secondKickers[0] &&
                    firstKickers[1] === secondKickers[1] &&
                    firstKickers[2] === secondKickers[2]) {
                    // True tie - return all winners
                    return winners;
                }
            }
            
            return [winners[0]];
        }
        
        // Helper function to find pair value
        function findPairValue(cards) {
            const counts = {};
            for (let card of cards) {
                counts[card.value] = (counts[card.value] || 0) + 1;
            }
            for (let [value, count] of Object.entries(counts)) {
                if (count === 2) return parseInt(value);
            }
            return 0;
        }
        
        // Helper function to get kickers (excluding the pair)
        function getKickers(cards, pairValue) {
            return cards
                .filter(card => card.value !== pairValue)
                .sort((a, b) => b.value - a.value)
                .slice(0, 3)
                .map(card => card.value);
        }
        
        // Helper function to break Four of a Kind ties
        function breakFourOfAKindTie(winners) {
            // For Four of a Kind, compare the kicker (5th card)
            winners.sort((a, b) => {
                const aKicker = getFourOfAKindKicker([...a.holeCards, ...gameState.communityCards]);
                const bKicker = getFourOfAKindKicker([...b.holeCards, ...gameState.communityCards]);
                return bKicker - aKicker; // Higher kicker wins
            });
            
            // Check if there's a true tie (same kicker)
            if (winners.length > 1) {
                const firstKicker = getFourOfAKindKicker([...winners[0].holeCards, ...gameState.communityCards]);
                const secondKicker = getFourOfAKindKicker([...winners[1].holeCards, ...gameState.communityCards]);
                
                if (firstKicker === secondKicker) {
                    // True tie - return all winners
                    return winners;
                }
            }
            
            return [winners[0]];
        }
        
        // Helper function to get the kicker for Four of a Kind
        function getFourOfAKindKicker(cards) {
            const counts = {};
            for (let card of cards) {
                counts[card.value] = (counts[card.value] || 0) + 1;
            }
            // Find the value that appears 4 times (the four of a kind)
            let fourValue = 0;
            for (let [value, count] of Object.entries(counts)) {
                if (count === 4) {
                    fourValue = parseInt(value);
                    break;
                }
            }
            // Return the kicker (the card that's not part of the four of a kind)
            for (let card of cards) {
                if (card.value !== fourValue) {
                    return card.value;
                }
            }
            return 0;
        }
        
        // Helper function to break Three of a Kind ties
        function breakThreeOfAKindTie(winners) {
            // For Three of a Kind, compare the three-of-a-kind value first, then kickers
            winners.sort((a, b) => {
                const aThreeValue = getThreeOfAKindValue([...a.holeCards, ...gameState.communityCards]);
                const bThreeValue = getThreeOfAKindValue([...b.holeCards, ...gameState.communityCards]);
                
                if (aThreeValue !== bThreeValue) {
                    return bThreeValue - aThreeValue; // Higher three-of-a-kind wins
                }
                
                // Same three-of-a-kind, compare kickers
                const aKickers = getThreeOfAKindKickers([...a.holeCards, ...gameState.communityCards], aThreeValue);
                const bKickers = getThreeOfAKindKickers([...b.holeCards, ...gameState.communityCards], bThreeValue);
                
                for (let i = 0; i < 2; i++) {
                    if (aKickers[i] !== bKickers[i]) {
                        return bKickers[i] - aKickers[i];
                    }
                }
                return 0;
            });
            
            // Check if there's a true tie (same three-of-a-kind and kickers)
            if (winners.length > 1) {
                const firstThreeValue = getThreeOfAKindValue([...winners[0].holeCards, ...gameState.communityCards]);
                const secondThreeValue = getThreeOfAKindValue([...winners[1].holeCards, ...gameState.communityCards]);
                const firstKickers = getThreeOfAKindKickers([...winners[0].holeCards, ...gameState.communityCards], firstThreeValue);
                const secondKickers = getThreeOfAKindKickers([...winners[1].holeCards, ...gameState.communityCards], secondThreeValue);
                
                if (firstThreeValue === secondThreeValue &&
                    firstKickers[0] === secondKickers[0] &&
                    firstKickers[1] === secondKickers[1]) {
                    // True tie - return all winners
                    return winners;
                }
            }
            
            return [winners[0]];
        }
        
        // Helper function to get the three-of-a-kind value
        function getThreeOfAKindValue(cards) {
            const counts = {};
            for (let card of cards) {
                counts[card.value] = (counts[card.value] || 0) + 1;
            }
            for (let [value, count] of Object.entries(counts)) {
                if (count === 3) return parseInt(value);
            }
            return 0;
        }
        
        // Helper function to get kickers for Three of a Kind
        function getThreeOfAKindKickers(cards, threeValue) {
            return cards
                .filter(card => card.value !== threeValue)
                .sort((a, b) => b.value - a.value)
                .slice(0, 2)
                .map(card => card.value);
        }
        
        // Helper function to break Full House ties
        function breakFullHouseTie(winners) {
            // For Full House, compare three-of-a-kind value first, then pair value
            winners.sort((a, b) => {
                const aFullHouse = getFullHouseValues([...a.holeCards, ...gameState.communityCards]);
                const bFullHouse = getFullHouseValues([...b.holeCards, ...gameState.communityCards]);
                
                // Compare three-of-a-kind values
                if (aFullHouse.threeValue !== bFullHouse.threeValue) {
                    return bFullHouse.threeValue - aFullHouse.threeValue;
                }
                
                // Same three-of-a-kind, compare pair values
                return bFullHouse.pairValue - aFullHouse.pairValue;
            });
            
            // Check if there's a true tie (same three-of-a-kind and pair)
            if (winners.length > 1) {
                const firstFullHouse = getFullHouseValues([...winners[0].holeCards, ...gameState.communityCards]);
                const secondFullHouse = getFullHouseValues([...winners[1].holeCards, ...gameState.communityCards]);
                
                if (firstFullHouse.threeValue === secondFullHouse.threeValue &&
                    firstFullHouse.pairValue === secondFullHouse.pairValue) {
                    // True tie - return all winners
                    return winners;
                }
            }
            
            return [winners[0]];
        }
        
        // Helper function to get Full House values
        function getFullHouseValues(cards) {
            const counts = {};
            for (let card of cards) {
                counts[card.value] = (counts[card.value] || 0) + 1;
            }
            
            let threeValue = 0;
            let pairValue = 0;
            
            for (let [value, count] of Object.entries(counts)) {
                if (count === 3) {
                    threeValue = parseInt(value);
                } else if (count === 2) {
                    pairValue = parseInt(value);
                }
            }
            
            return { threeValue, pairValue };
        }
        
        // Helper function to break Two Pair ties
        function breakTwoPairTie(winners) {
            // For Two Pair, compare higher pair, then lower pair, then kicker
            winners.sort((a, b) => {
                const aTwoPair = getTwoPairValues([...a.holeCards, ...gameState.communityCards]);
                const bTwoPair = getTwoPairValues([...b.holeCards, ...gameState.communityCards]);
                
                // Compare higher pair
                if (aTwoPair.higherPair !== bTwoPair.higherPair) {
                    return bTwoPair.higherPair - aTwoPair.higherPair;
                }
                
                // Same higher pair, compare lower pair
                if (aTwoPair.lowerPair !== bTwoPair.lowerPair) {
                    return bTwoPair.lowerPair - aTwoPair.lowerPair;
                }
                
                // Same pairs, compare kicker
                return bTwoPair.kicker - aTwoPair.kicker;
            });
            
            // Check if there's a true tie (same higher pair, lower pair, and kicker)
            if (winners.length > 1) {
                const firstTwoPair = getTwoPairValues([...winners[0].holeCards, ...gameState.communityCards]);
                const secondTwoPair = getTwoPairValues([...winners[1].holeCards, ...gameState.communityCards]);
                
                if (firstTwoPair.higherPair === secondTwoPair.higherPair &&
                    firstTwoPair.lowerPair === secondTwoPair.lowerPair &&
                    firstTwoPair.kicker === secondTwoPair.kicker) {
                    // True tie - return all winners
                    return winners;
                }
            }
            
            return [winners[0]];
        }
        
        // Helper function to get Two Pair values
        function getTwoPairValues(cards) {
            const counts = {};
            for (let card of cards) {
                counts[card.value] = (counts[card.value] || 0) + 1;
            }
            
            const pairs = [];
            let kicker = 0;
            
            for (let [value, count] of Object.entries(counts)) {
                if (count === 2) {
                    pairs.push(parseInt(value));
                } else if (count === 1) {
                    kicker = Math.max(kicker, parseInt(value));
                }
            }
            
            pairs.sort((a, b) => b - a); // Sort pairs in descending order
            
            return {
                higherPair: pairs[0] || 0,
                lowerPair: pairs[1] || 0,
                kicker: kicker
            };
        }
        
        // Helper function to break Straight ties
        function breakStraightTie(winners) {
            // For Straight, compare the highest card in the straight
            winners.sort((a, b) => {
                const aStraight = findHighestStraight([...a.holeCards, ...gameState.communityCards]);
                const bStraight = findHighestStraight([...b.holeCards, ...gameState.communityCards]);
                
                if (aStraight.length > 0 && bStraight.length > 0) {
                    return bStraight[0].value - aStraight[0].value;
                }
                return 0;
            });
            
            // Check if there's a true tie (same highest card)
            if (winners.length > 1) {
                const firstStraight = findHighestStraight([...winners[0].holeCards, ...gameState.communityCards]);
                const secondStraight = findHighestStraight([...winners[1].holeCards, ...gameState.communityCards]);
                
                if (firstStraight.length > 0 && secondStraight.length > 0 && 
                    firstStraight[0].value === secondStraight[0].value) {
                    // True tie - return all winners
                    return winners;
                }
            }
            
            return [winners[0]];
        }
        
        // Helper function to break Flush ties
        function breakFlushTie(winners) {
            // For Flush, compare the highest card in the flush
            winners.sort((a, b) => {
                const aFlush = getFlushCards([...a.holeCards, ...gameState.communityCards]);
                const bFlush = getFlushCards([...b.holeCards, ...gameState.communityCards]);
                
                if (aFlush.length > 0 && bFlush.length > 0) {
                    // Compare all 5 cards in descending order
                    for (let i = 0; i < 5; i++) {
                        if (aFlush[i].value !== bFlush[i].value) {
                            return bFlush[i].value - aFlush[i].value;
                        }
                    }
                }
                return 0;
            });
            
            // Check if there's a true tie (all 5 flush cards are the same)
            if (winners.length > 1) {
                const firstFlush = getFlushCards([...winners[0].holeCards, ...gameState.communityCards]);
                const secondFlush = getFlushCards([...winners[1].holeCards, ...gameState.communityCards]);
                
                if (firstFlush.length > 0 && secondFlush.length > 0) {
                    let isTrueTie = true;
                    for (let i = 0; i < 5; i++) {
                        if (firstFlush[i].value !== secondFlush[i].value) {
                            isTrueTie = false;
                            break;
                        }
                    }
                    
                    if (isTrueTie) {
                        // True tie - return all winners
                        return winners;
                    }
                }
            }
            
            return [winners[0]];
        }
        
        // Helper function to get Flush cards
        function getFlushCards(cards) {
            const suits = {};
            for (let card of cards) {
                if (!suits[card.suit]) suits[card.suit] = [];
                suits[card.suit].push(card);
            }
            
            for (let suit in suits) {
                if (suits[suit].length >= 5) {
                    return suits[suit]
                        .sort((a, b) => b.value - a.value)
                        .slice(0, 5);
                }
            }
            return [];
        }
        
        // Function to show explanation overlay
        function showExplanationOverlay(content) {
            console.log('showExplanationOverlay called with content length:', content.length);
            const overlay = document.getElementById('explanationOverlay');
            const contentDiv = document.getElementById('explanationContent');
            
            if (overlay && contentDiv) {
                // Reset any forced display:none that might have been set
                overlay.style.display = '';
                contentDiv.innerHTML = content;
                overlay.classList.add('show');
                console.log('Overlay shown successfully');
            } else {
                console.error('Overlay or content elements not found');
            }
        }
        
        // Function to close explanation overlay
        function closeExplanation() {
            console.log('closeExplanation function called');
            const overlay = document.getElementById('explanationOverlay');
            console.log('Overlay element:', overlay);
            if (overlay) {
                overlay.classList.remove('show');
                console.log('Removed show class from overlay');
                // Clear the content to free memory
                const contentDiv = document.getElementById('explanationContent');
                if (contentDiv) {
                    contentDiv.innerHTML = '';
                    console.log('Cleared overlay content');
                }
            } else {
                console.error('Explanation overlay not found!');
            }
        }
        
        // Make function globally accessible for debugging
        window.closeExplanation = closeExplanation;
        
        // Debug function to check overlay state
        window.debugOverlay = function() {
            const overlay = document.getElementById('explanationOverlay');
            const contentDiv = document.getElementById('explanationContent');
            console.log('=== OVERLAY DEBUG ===');
            console.log('Overlay element:', overlay);
            console.log('Content div:', contentDiv);
            if (overlay) {
                console.log('Overlay classes:', overlay.className);
                console.log('Overlay display style:', overlay.style.display);
                console.log('Overlay visibility style:', overlay.style.visibility);
                console.log('Overlay opacity style:', overlay.style.opacity);
            }
            if (contentDiv) {
                console.log('Content innerHTML length:', contentDiv.innerHTML.length);
            }
            console.log('====================');
        };
        
        // Debug function to print current game state
        window.debugGameState = function() {
            console.log('=== GAME STATE DEBUG ===');
            console.log('Current Stage:', gameState.currentStage);
            console.log('Community Cards:', gameState.communityCards.map(card => `${card.rank}${card.suit}`).join(', '));
            console.log('Players:');
            gameState.players.forEach((player, index) => {
                console.log(`  Player ${index + 1} (${player.name}):`);
                console.log(`    Hole Cards: ${player.holeCards.map(card => `${card.rank}${card.suit}`).join(', ')}`);
                console.log(`    Win Probability: ${player.probability}%`);
                if (player.holeCards.length > 0) {
                    const allCards = [...player.holeCards, ...gameState.communityCards];
                    const handRank = getHandRankAtStage(allCards, gameState.currentStage);
                    console.log(`    Hand: ${handRank.name}`);
                }
            });
            console.log('====================');
        };
        
        // Debug function to print detailed hand analysis
        window.debugHandAnalysis = function() {
            console.log('=== DETAILED HAND ANALYSIS ===');
            gameState.players.forEach((player, index) => {
                if (player.holeCards.length > 0) {
                    console.log(`\nPlayer ${index + 1} (${player.name}):`);
                    const allCards = [...player.holeCards, ...gameState.communityCards];
                    console.log(`  All Cards: ${allCards.map(card => `${card.rank}${card.suit}`).join(', ')}`);
                    
                    const handRank = getHandRankAtStage(allCards, gameState.currentStage);
                    console.log(`  Hand Type: ${handRank.name}`);
                    console.log(`  Hand Score: ${handRank.score}`);
                    
                    // Show best 5-card combination
                    if (allCards.length >= 5) {
                        const bestHand = findBestFiveCardHand(allCards);
                        console.log(`  Best 5-Card Hand: ${bestHand.name} (Score: ${bestHand.score})`);
                    }
                }
            });
            console.log('============================');
        };
        
        // Debug function to test tie-breaking logic
        window.debugTieBreaking = function() {
            console.log('=== TIE-BREAKING DEBUG ===');
            const winners = findWinners();
            console.log('Final winners from findWinners():', winners);
            
            // Test hand comparison directly
            if (gameState.currentStage === 'river' && gameState.players.length >= 2) {
                console.log('\nTesting Hand comparison:');
                const player1AllCards = [...gameState.players[0].holeCards, ...gameState.communityCards];
                const player2AllCards = [...gameState.players[1].holeCards, ...gameState.communityCards];
                
                const hand1 = getHandRankAtStage(player1AllCards, gameState.currentStage);
                const hand2 = getHandRankAtStage(player2AllCards, gameState.currentStage);
                
                console.log(`Player 1: ${hand1.name} (Score: ${hand1.score})`);
                console.log(`Player 2: ${hand2.name} (Score: ${hand2.score})`);
                
                if (hand1.name === hand2.name) {
                    console.log('\nSame hand type - testing tie-breaking:');
                    
                    if (hand1.name === 'Two Pair') {
                        const p1TwoPair = getTwoPairValues(player1AllCards);
                        const p2TwoPair = getTwoPairValues(player2AllCards);
                        
                        console.log(`Player 1 Two Pair: ${p1TwoPair.higherPair}s and ${p1TwoPair.lowerPair}s with ${p1TwoPair.kicker} kicker`);
                        console.log(`Player 2 Two Pair: ${p2TwoPair.higherPair}s and ${p2TwoPair.lowerPair}s with ${p2TwoPair.kicker} kicker`);
                        
                        if (p1TwoPair.higherPair !== p2TwoPair.higherPair) {
                            console.log(`Higher pair comparison: ${Math.max(p1TwoPair.higherPair, p2TwoPair.higherPair)} > ${Math.min(p1TwoPair.higherPair, p2TwoPair.higherPair)}`);
                        } else if (p1TwoPair.lowerPair !== p2TwoPair.lowerPair) {
                            console.log(`Lower pair comparison: ${Math.max(p1TwoPair.lowerPair, p2TwoPair.lowerPair)} > ${Math.min(p1TwoPair.lowerPair, p2TwoPair.lowerPair)}`);
                        } else {
                            console.log(`Kicker comparison: ${Math.max(p1TwoPair.kicker, p2TwoPair.kicker)} > ${Math.min(p1TwoPair.kicker, p2TwoPair.kicker)}`);
                        }
                    }
                }
            }
            console.log('============================');
        };
        
        // Test function to manually trigger overlay
        window.testOverlay = function() {
            console.log('Testing overlay manually...');
            const testContent = '<h3>🧪 Test Overlay</h3><div class="hand-explanation">This is a test overlay to verify functionality.</div>';
            try {
                showExplanationOverlay(testContent);
                console.log('Test overlay should be visible now');
            } catch (error) {
                console.error('Error showing test overlay:', error);
            }
        };
        
        // Close overlay when clicking outside
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('explanationOverlay').addEventListener('click', function(e) {
                if (e.target === this) {
                    closeExplanation();
                }
            });
            
            // Also add click event to close button as backup
            const closeBtn = document.querySelector('.close-explanation-btn');
            if (closeBtn) {
                closeBtn.addEventListener('click', function(e) {
                    console.log('Close button clicked via event listener');
                    e.preventDefault();
                    e.stopPropagation();
                    closeExplanation();
                });
            }
        });
        
        // Function to get detailed explanation of why a player won
        function getDetailedWinExplanation(selectedPlayer, actualWinner) {
            const selectedHand = getHandRankAtStage([...selectedPlayer.holeCards, ...gameState.communityCards], gameState.currentStage);
            const actualHand = getHandRankAtStage([...actualWinner.holeCards, ...gameState.communityCards], gameState.currentStage);
            
            // If hands are different types, explain the hand ranking
            if (selectedHand.name !== actualHand.name) {
                return `${selectedPlayer.name} has ${selectedHand.name} but ${actualWinner.name} has ${actualHand.name}. ${actualHand.name} beats ${selectedHand.name} in poker hand rankings.`;
            }
            
            // If hands are the same type, explain why one is better
            if (selectedHand.name === 'High Card') {
                return getHighCardComparison(selectedPlayer, actualWinner);
            } else if (selectedHand.name === 'One Pair') {
                return getOnePairComparison(selectedPlayer, actualWinner);
            } else if (selectedHand.name === 'Two Pair') {
                return getTwoPairComparison(selectedPlayer, actualWinner);
            } else if (selectedHand.name === 'Three of a Kind') {
                return getThreeOfAKindComparison(selectedPlayer, actualWinner);
            } else if (selectedHand.name === 'Straight') {
                return getStraightComparison(selectedPlayer, actualWinner);
            } else if (selectedHand.name === 'Flush') {
                return getFlushComparison(selectedPlayer, actualWinner);
            } else if (selectedHand.name === 'Full House') {
                return getFullHouseComparison(selectedPlayer, actualWinner);
            } else if (selectedHand.name === 'Four of a Kind') {
                return getFourOfAKindComparison(selectedPlayer, actualWinner);
            } else if (selectedHand.name === 'Straight Flush') {
                return getStraightFlushComparison(selectedPlayer, actualWinner);
            } else if (selectedHand.name === 'Royal Flush') {
                return getRoyalFlushComparison(selectedPlayer, actualWinner);
            }
            
            return `Both players have ${selectedHand.name}, but ${actualWinner.name} has a stronger version.`;
        }
        
        // Function to get tie explanation
        function getTieExplanation(winners) {
            console.log('getTieExplanation called with winners:', winners);
            
            const handType = getHandRankAtStage([...winners[0].holeCards, ...gameState.communityCards], gameState.currentStage).name;
            console.log('Hand type for tie:', handType);
            
            const winnerNames = winners.map(w => w.name).join(', ');
            console.log('Winner names:', winnerNames);
            
            // Get detailed hand information for the first winner to show what they all have
            const firstWinner = winners[0];
            console.log('First winner:', firstWinner);
            
            const handDetails = getDetailedHandDescriptionForTie(firstWinner, handType);
            console.log('Hand details:', handDetails);
            
            // Check if this is a community card tie (all players using the same 5 community cards)
            const isCommunityCardTie = checkIfCommunityCardTie(winners);
            console.log('Is community card tie:', isCommunityCardTie);
            
            let tieMessage = `🏆 TIE! ${winnerNames} have tied with identical ${handType}${handDetails}.`;
            
            if (isCommunityCardTie) {
                tieMessage += ` All players are using the same 5 community cards as their best hand, making this a true tie.`;
            } else {
                tieMessage += ` All kickers were evaluated and found to be exactly the same, making this a true tie.`;
            }
            
            console.log('Final tie message:', tieMessage);
            return tieMessage;
        }
        
        // Helper function to check if all players are using the same community cards
        function checkIfCommunityCardTie(winners) {
            if (winners.length < 2) return false;
            
            // Get the best 5-card hand for each player
            const playerHands = winners.map(w => {
                const allCards = [...w.holeCards, ...gameState.communityCards];
                return findBestFiveCardHand(allCards);
            });
            
            // Check if all hands are identical
            const firstHand = playerHands[0];
            for (let i = 1; i < playerHands.length; i++) {
                if (playerHands[i].name !== firstHand.name || playerHands[i].score !== firstHand.score) {
                    return false;
                }
            }
            
            // If all hands are identical, check if they're all using the same 5 cards
            // This is a simplified check - in practice, we'd need to compare the actual cards used
            return true;
        }
        
        // Helper function to get detailed hand description for tie explanation
        function getDetailedHandDescriptionForTie(player, handType) {
            const cards = [...player.holeCards, ...gameState.communityCards];
            
            switch (handType) {
                case 'High Card':
                    const highCard = getHighCardName(cards);
                    return ` (${highCard})`;
                    
                case 'One Pair':
                    const pairValue = findPairValue(cards);
                    const pairName = getCardName({ value: pairValue, suit: '♠' });
                    const kickers = getKickers(cards, pairValue);
                    const kickerNames = kickers.map(k => getCardName({ value: k, suit: '♠' })).join(', ');
                    return ` (${pairName}s with ${kickerNames} kickers)`;
                    
                case 'Two Pair':
                    const pairValues = Object.entries(getCardCounts(cards))
                        .filter(([value, count]) => count === 2)
                        .map(([value, count]) => parseInt(value))
                        .sort((a, b) => b - a);
                    const kicker = cards.find(card => card.value !== pairValues[0] && card.value !== pairValues[1]);
                    return ` (${getCardName({ value: pairValues[0], suit: '♠' })}s and ${getCardName({ value: pairValues[1], suit: '♠' })}s with ${getCardName(kicker)} kicker)`;
                    
                case 'Three of a Kind':
                    const threeValue = Object.entries(getCardCounts(cards)).find(([value, count]) => count === 3)[0];
                    const threeKickers = cards
                        .filter(card => card.value !== parseInt(threeValue))
                        .sort((a, b) => b.value - a.value)
                        .slice(0, 2)
                        .map(card => getCardName(card))
                        .join(', ');
                    return ` (${getCardName({ value: parseInt(threeValue), suit: '♠' })}s with ${threeKickers} kickers)`;
                    
                case 'Straight':
                    const straight = findHighestStraight(cards);
                    return ` (${getCardName(straight[0])} high)`;
                    
                case 'Flush':
                    const suits = {};
                    for (let card of cards) {
                        suits[card.suit] = (suits[card.suit] || 0) + 1;
                    }
                    const flushSuit = Object.entries(suits).find(([suit, count]) => count >= 5)[0];
                    const flushCards = cards
                        .filter(card => card.suit === flushSuit)
                        .sort((a, b) => b.value - a.value)
                        .slice(0, 5)
                        .map(card => getCardName(card))
                        .join(', ');
                    return ` (${getSuitName(flushSuit)} flush: ${flushCards})`;
                    
                case 'Full House':
                    const counts = getCardCounts(cards);
                    const threeVal = Object.entries(counts).find(([value, count]) => count === 3)[0];
                    const twoVal = Object.entries(counts).find(([value, count]) => count === 2)[0];
                    return ` (${getCardName({ value: parseInt(threeVal), suit: '♠' })}s full of ${getCardName({ value: parseInt(twoVal), suit: '♠' })}s)`;
                    
                case 'Four of a Kind':
                    const fourValue = Object.entries(counts).find(([value, count]) => count === 4)[0];
                    const fourKicker = cards.find(card => card.value !== parseInt(fourValue));
                    return ` (${getCardName({ value: parseInt(fourValue), suit: '♠' })}s with ${getCardName(fourKicker)} kicker)`;
                    
                case 'Straight Flush':
                    const straightFlush = findHighestStraight(cards);
                    const flushSuit2 = straightFlush[0].suit;
                    return ` (${getCardName(straightFlush[0])} high ${getSuitName(flushSuit2)} straight flush)`;
                    
                case 'Royal Flush':
                    return ` (${getSuitName(cards[0].suit)} royal flush)`;
                    
                default:
                    return '';
            }
        }
        
        // Detailed comparison functions for different hand types
        function getHighCardComparison(selectedPlayer, actualWinner) {
            const selectedCards = [...selectedPlayer.holeCards, ...gameState.communityCards].sort((a, b) => b.value - a.value).slice(0, 5);
            const actualCards = [...actualWinner.holeCards, ...gameState.communityCards].sort((a, b) => b.value - a.value).slice(0, 5);
            
            for (let i = 0; i < 5; i++) {
                if (selectedCards[i].value !== actualCards[i].value) {
                    const selectedCardName = getCardName(selectedCards[i]);
                    const actualCardName = getCardName(actualCards[i]);
                    if (i === 0) {
                        return `${selectedPlayer.name} has ${selectedCardName} as high card, but ${actualWinner.name} has ${actualCardName}. ${actualCardName} beats ${selectedCardName}.`;
                    } else if (i === 1) {
                        return `Both players have the same highest card, but ${actualWinner.name} wins with ${actualCardName} second highest vs ${selectedPlayer.name}'s ${selectedCardName} second highest.`;
                    } else if (i === 2) {
                        return `Both players have the same two highest cards, but ${actualWinner.name} wins with ${actualCardName} third highest vs ${selectedPlayer.name}'s ${selectedCardName} third highest.`;
                    } else if (i === 3) {
                        return `Both players have the same three highest cards, but ${actualWinner.name} wins with ${actualCardName} fourth highest vs ${selectedPlayer.name}'s ${selectedCardName} fourth highest.`;
                    } else {
                        return `Both players have the same four highest cards, but ${actualWinner.name} wins with ${actualCardName} fifth highest vs ${selectedPlayer.name}'s ${selectedCardName} fifth highest.`;
                    }
                }
            }
            return `Both players have identical high cards. This should be a tie, but ${actualWinner.name} wins due to suit ranking.`;
        }
        
        function getOnePairComparison(selectedPlayer, actualWinner) {
            const selectedPair = findPairValue([...selectedPlayer.holeCards, ...gameState.communityCards]);
            const actualPair = findPairValue([...actualWinner.holeCards, ...gameState.communityCards]);
            
            if (selectedPair !== actualPair) {
                const selectedPairName = getCardName({ value: selectedPair, suit: '♠' });
                const actualPairName = getCardName({ value: actualPair, suit: '♠' });
                return `${selectedPlayer.name} has a pair of ${selectedPairName}s, but ${actualWinner.name} has a pair of ${actualPairName}s. ${actualPairName}s beat ${selectedPairName}s.`;
            }
            
            // Same pair, compare kickers
            const selectedKickers = getKickers([...selectedPlayer.holeCards, ...gameState.communityCards], selectedPair);
            const actualKickers = getKickers([...actualWinner.holeCards, ...gameState.communityCards], actualPair);
            
            for (let i = 0; i < 3; i++) {
                if (selectedKickers[i] !== actualKickers[i]) {
                    const selectedKickerName = getCardName({ value: selectedKickers[i], suit: '♠' });
                    const actualKickerName = getCardName({ value: actualKickers[i], suit: '♠' });
                    
                    if (i === 0) {
                        return `Both players have the same pair of ${getCardName({ value: selectedPair, suit: '♠' })}s, but ${actualWinner.name} wins with ${actualKickerName} kicker vs ${selectedPlayer.name}'s ${selectedKickerName} kicker.`;
                    } else if (i === 1) {
                        return `Both players have the same pair of ${getCardName({ value: selectedPair, suit: '♠' })}s and same highest kicker, but ${actualWinner.name} wins with ${actualKickerName} second kicker vs ${selectedPlayer.name}'s ${selectedKickerName} second kicker.`;
                    } else {
                        return `Both players have the same pair of ${getCardName({ value: selectedPair, suit: '♠' })}s and same two highest kickers, but ${actualWinner.name} wins with ${actualKickerName} third kicker vs ${selectedPlayer.name}'s ${selectedKickerName} third kicker.`;
                    }
                }
            }
            
            return `Both players have identical pairs and kickers. This should be a tie, but ${actualWinner.name} wins due to suit ranking.`;
        }
        
        function getTwoPairComparison(selectedPlayer, actualWinner) {
            // Get the pair values for both players
            const selectedCards = [...selectedPlayer.holeCards, ...gameState.communityCards];
            const actualCards = [...actualWinner.holeCards, ...gameState.communityCards];
            
            const selectedPairValues = Object.entries(getCardCounts(selectedCards))
                .filter(([value, count]) => count === 2)
                .map(([value, count]) => parseInt(value))
                .sort((a, b) => b - a);
            
            const actualPairValues = Object.entries(getCardCounts(actualCards))
                .filter(([value, count]) => count === 2)
                .map(([value, count]) => parseInt(value))
                .sort((a, b) => b - a);
            
            // Compare high pairs first
            if (selectedPairValues[0] !== actualPairValues[0]) {
                const selectedHighPair = getCardName({ value: selectedPairValues[0], suit: '♠' });
                const actualHighPair = getCardName({ value: actualPairValues[0], suit: '♠' });
                return `${selectedPlayer.name} has Two Pair: ${selectedHighPair}s and ${getCardName({ value: selectedPairValues[1], suit: '♠' })}s, but ${actualWinner.name} has Two Pair: ${actualHighPair}s and ${getCardName({ value: actualPairValues[1], suit: '♠' })}s. ${actualHighPair}s beat ${selectedHighPair}s.`;
            }
            
            // Same high pair, compare low pairs
            if (selectedPairValues[1] !== actualPairValues[1]) {
                const selectedLowPair = getCardName({ value: selectedPairValues[1], suit: '♠' });
                const actualLowPair = getCardName({ value: actualPairValues[1], suit: '♠' });
                return `Both players have Two Pair with ${getCardName({ value: selectedPairValues[0], suit: '♠' })}s as high pair, but ${actualWinner.name} wins with ${actualLowPair}s vs ${selectedPlayer.name}'s ${selectedLowPair}s as second pair.`;
            }
            
            // Same pairs, compare kickers
            const selectedKicker = selectedCards.find(card => card.value !== selectedPairValues[0] && card.value !== selectedPairValues[1]);
            const actualKicker = actualCards.find(card => card.value !== actualPairValues[0] && card.value !== actualPairValues[1]);
            
            if (selectedKicker.value !== actualKicker.value) {
                const selectedKickerName = getCardName(selectedKicker);
                const actualKickerName = getCardName(actualKicker);
                return `Both players have identical Two Pair (${getCardName({ value: selectedPairValues[0], suit: '♠' })}s and ${getCardName({ value: selectedPairValues[1], suit: '♠' })}s), but ${actualWinner.name} wins with ${actualKickerName} kicker vs ${selectedPlayer.name}'s ${selectedKickerName} kicker.`;
            }
            
            return `Both players have identical Two Pair and kickers. This should be a tie, but ${actualWinner.name} wins due to suit ranking.`;
        }
        
        // Helper function to get card counts
        function getCardCounts(cards) {
            const counts = {};
            for (let card of cards) {
                counts[card.value] = (counts[card.value] || 0) + 1;
            }
            return counts;
        }
        
        function getThreeOfAKindComparison(selectedPlayer, actualWinner) {
            const selectedCards = [...selectedPlayer.holeCards, ...gameState.communityCards];
            const actualCards = [...actualWinner.holeCards, ...gameState.communityCards];
            
            const selectedCounts = getCardCounts(selectedCards);
            const actualCounts = getCardCounts(actualCards);
            
            const selectedThreeValue = Object.entries(selectedCounts).find(([value, count]) => count === 3)[0];
            const actualThreeValue = Object.entries(actualCounts).find(([value, count]) => count === 3)[0];
            
            if (selectedThreeValue !== actualThreeValue) {
                const selectedThreeName = getCardName({ value: parseInt(selectedThreeValue), suit: '♠' });
                const actualThreeName = getCardName({ value: parseInt(actualThreeValue), suit: '♠' });
                return `${selectedPlayer.name} has Three of a Kind: ${selectedThreeName}s, but ${actualWinner.name} has Three of a Kind: ${actualThreeName}s. ${actualThreeName}s beat ${selectedThreeName}s.`;
            }
            
            // Same three of a kind, compare kickers
            const selectedKickers = selectedCards
                .filter(card => card.value !== parseInt(selectedThreeValue))
                .sort((a, b) => b.value - a.value)
                .slice(0, 2);
            
            const actualKickers = actualCards
                .filter(card => card.value !== parseInt(actualThreeValue))
                .sort((a, b) => b.value - a.value)
                .slice(0, 2);
            
            for (let i = 0; i < 2; i++) {
                if (selectedKickers[i].value !== actualKickers[i].value) {
                    const selectedKickerName = getCardName(selectedKickers[i]);
                    const actualKickerName = getCardName(actualKickers[i]);
                    return `Both players have Three of a Kind: ${getCardName({ value: parseInt(selectedThreeValue), suit: '♠' })}s, but ${actualWinner.name} wins with ${actualKickerName} kicker vs ${selectedPlayer.name}'s ${selectedKickerName} kicker.`;
                }
            }
            
            return `Both players have identical Three of a Kind and kickers. This should be a tie, but ${actualWinner.name} wins due to suit ranking.`;
        }
        
        function getStraightComparison(selectedPlayer, actualWinner) {
            const selectedCards = [...selectedPlayer.holeCards, ...gameState.communityCards];
            const actualCards = [...actualWinner.holeCards, ...gameState.communityCards];
            
            // Find the highest straight for each player
            const selectedStraight = findHighestStraight(selectedCards);
            const actualStraight = findHighestStraight(actualCards);
            
            if (selectedStraight[0].value !== actualStraight[0].value) {
                const selectedTopCard = getCardName(selectedStraight[0]);
                const actualTopCard = getCardName(actualStraight[0]);
                return `Both players have a Straight, but ${actualWinner.name} has ${actualTopCard} high vs ${selectedPlayer.name}'s ${selectedTopCard} high. ${actualTopCard} beats ${selectedTopCard}.`;
            }
            
            return `Both players have identical Straight. This should be a tie, but ${actualWinner.name} wins due to suit ranking.`;
        }
        
        // Helper function to find the highest straight
        function findHighestStraight(cards) {
            if (!cards || cards.length < 5) {
                return [];
            }
            
            const sorted = cards.sort((a, b) => b.value - a.value);
            
            // Check for 5 consecutive cards starting from the highest
            for (let i = 0; i <= sorted.length - 5; i++) {
                let consecutive = true;
                for (let j = 0; j < 4; j++) {
                    if (sorted[i + j].value - sorted[i + j + 1].value !== 1) {
                        consecutive = false;
                        break;
                    }
                }
                if (consecutive) {
                    return sorted.slice(i, i + 5);
                }
            }
            return [];
        }
        
        function getFlushComparison(selectedPlayer, actualWinner) {
            const selectedCards = [...selectedPlayer.holeCards, ...gameState.communityCards];
            const actualCards = [...actualWinner.holeCards, ...gameState.communityCards];
            
            // Find the flush suit
            const selectedSuits = {};
            const actualSuits = {};
            
            for (let card of selectedCards) {
                selectedSuits[card.suit] = (selectedSuits[card.suit] || 0) + 1;
            }
            for (let card of actualCards) {
                actualSuits[card.suit] = (actualSuits[card.suit] || 0) + 1;
            }
            
            const selectedFlushSuit = Object.entries(selectedSuits).find(([suit, count]) => count >= 5)[0];
            const actualFlushSuit = Object.entries(actualSuits).find(([suit, count]) => count >= 5)[0];
            
            // If different suits, the higher suit wins (this is a simplified rule)
            if (selectedFlushSuit !== actualFlushSuit) {
                return `Both players have a Flush, but ${actualWinner.name} has ${getSuitName(actualFlushSuit)} flush vs ${selectedPlayer.name}'s ${getSuitName(selectedFlushSuit)} flush. ${getSuitName(actualFlushSuit)} flush beats ${getSuitName(selectedFlushSuit)} flush.`;
            }
            
            const selectedFlushCards = selectedCards
                .filter(card => card.suit === selectedFlushSuit)
                .sort((a, b) => b.value - a.value)
                .slice(0, 5);
            
            const actualFlushCards = actualCards
                .filter(card => card.suit === actualFlushSuit)
                .sort((a, b) => b.value - a.value)
                .slice(0, 5);
            
            for (let i = 0; i < 5; i++) {
                if (selectedFlushCards[i].value !== actualFlushCards[i].value) {
                    const selectedCardName = getCardName(selectedFlushCards[i]);
                    const actualCardName = getCardName(actualFlushCards[i]);
                    if (i === 0) {
                        return `Both players have a ${getSuitName(selectedFlushSuit)} flush, but ${actualWinner.name} has ${actualCardName} vs ${selectedPlayer.name}'s ${selectedCardName} as the highest card.`;
                    } else {
                        return `Both players have the same ${i} highest cards in their ${getSuitName(selectedFlushSuit)} flush, but ${actualWinner.name} wins with ${actualCardName} vs ${selectedPlayer.name}'s ${selectedCardName}.`;
                    }
                }
            }
            
            return `Both players have identical ${getSuitName(selectedFlushSuit)} flush. This should be a tie, but ${actualWinner.name} wins due to suit ranking.`;
        }
        
        function getFullHouseComparison(selectedPlayer, actualWinner) {
            const selectedCards = [...selectedPlayer.holeCards, ...gameState.communityCards];
            const actualCards = [...actualWinner.holeCards, ...gameState.communityCards];
            
            const selectedCounts = getCardCounts(selectedCards);
            const actualCounts = getCardCounts(actualCards);
            
            const selectedThreeValue = Object.entries(selectedCounts).find(([value, count]) => count === 3)[0];
            const actualThreeValue = Object.entries(actualCounts).find(([value, count]) => count === 3)[0];
            
            const selectedTwoValue = Object.entries(selectedCounts).find(([value, count]) => count === 2)[0];
            const actualTwoValue = Object.entries(actualCounts).find(([value, count]) => count === 2)[0];
            
            if (selectedThreeValue !== actualThreeValue) {
                const selectedThreeName = getCardName({ value: parseInt(selectedThreeValue), suit: '♠' });
                const actualThreeName = getCardName({ value: parseInt(actualThreeValue), suit: '♠' });
                return `${selectedPlayer.name} has Full House: ${selectedThreeName}s full of ${getCardName({ value: parseInt(selectedTwoValue), suit: '♠' })}s, but ${actualWinner.name} has Full House: ${actualThreeName}s full of ${getCardName({ value: parseInt(actualTwoValue), suit: '♠' })}s. ${actualThreeName}s beat ${selectedThreeName}s.`;
            }
            
            // Same three of a kind, compare the pair
            if (selectedTwoValue !== actualTwoValue) {
                const selectedTwoName = getCardName({ value: parseInt(selectedTwoValue), suit: '♠' });
                const actualTwoName = getCardName({ value: parseInt(actualTwoValue), suit: '♠' });
                return `Both players have Full House with ${getCardName({ value: parseInt(selectedThreeValue), suit: '♠' })}s as three of a kind, but ${actualWinner.name} wins with ${actualTwoName}s vs ${selectedPlayer.name}'s ${selectedTwoName}s as the pair.`;
            }
            
            return `Both players have identical Full House. This should be a tie, but ${actualWinner.name} wins due to suit ranking.`;
        }
        
        function getFourOfAKindComparison(selectedPlayer, actualWinner) {
            const selectedCards = [...selectedPlayer.holeCards, ...gameState.communityCards];
            const actualCards = [...actualWinner.holeCards, ...gameState.communityCards];
            
            const selectedCounts = getCardCounts(selectedCards);
            const actualCounts = getCardCounts(actualCards);
            
            const selectedFourValue = Object.entries(selectedCounts).find(([value, count]) => count === 4)[0];
            const actualFourValue = Object.entries(actualCounts).find(([value, count]) => count === 4)[0];
            
            if (selectedFourValue !== actualFourValue) {
                const selectedFourName = getCardName({ value: parseInt(selectedFourValue), suit: '♠' });
                const actualFourName = getCardName({ value: parseInt(actualFourValue), suit: '♠' });
                return `${selectedPlayer.name} has Four of a Kind: ${selectedFourName}s, but ${actualWinner.name} has Four of a Kind: ${actualFourName}s. ${actualFourName}s beat ${selectedFourName}s.`;
            }
            
            // Same four of a kind, compare kicker
            const selectedKicker = selectedCards.find(card => card.value !== parseInt(selectedFourValue));
            const actualKicker = actualCards.find(card => card.value !== parseInt(actualFourValue));
            
            if (selectedKicker.value !== actualKicker.value) {
                const selectedKickerName = getCardName(selectedKicker);
                const actualKickerName = getCardName(actualKicker);
                return `Both players have Four of a Kind: ${getCardName({ value: parseInt(selectedFourValue), suit: '♠' })}s, but ${actualWinner.name} wins with ${actualKickerName} kicker vs ${selectedPlayer.name}'s ${selectedKickerName} kicker.`;
            }
            
            return `Both players have identical Four of a Kind and kickers. This should be a tie, but ${actualWinner.name} wins due to suit ranking.`;
        }
        
        // Helper function to get card name
        function getCardName(card) {
            // Add error checking
            if (!card || typeof card.value === 'undefined') {
                console.error('getCardName called with invalid card:', card);
                return 'Unknown';
            }
            
            switch (card.value) {
                case 14: return 'Ace';
                case 13: return 'King';
                case 12: return 'Queen';
                case 11: return 'Jack';
                default: return card.value.toString();
            }
        }
        
        function getStraightFlushComparison(selectedPlayer, actualWinner) {
            const selectedCards = [...selectedPlayer.holeCards, ...gameState.communityCards];
            const actualCards = [...actualWinner.holeCards, ...gameState.communityCards];
            
            // Find the highest straight flush for each player
            const selectedStraightFlush = findHighestStraight(selectedCards);
            const actualStraightFlush = findHighestStraight(actualCards);
            
            if (selectedStraightFlush[0].value !== actualStraightFlush[0].value) {
                const selectedTopCard = getCardName(selectedStraightFlush[0]);
                const actualTopCard = getCardName(actualStraightFlush[0]);
                return `Both players have a Straight Flush, but ${actualWinner.name} has ${actualTopCard} high vs ${selectedPlayer.name}'s ${selectedTopCard} high. ${actualTopCard} beats ${selectedTopCard}.`;
            }
            
            return `Both players have identical Straight Flush. This should be a tie, but ${actualWinner.name} wins due to suit ranking.`;
        }
        
        function getRoyalFlushComparison(selectedPlayer, actualWinner) {
            // Royal Flush is always the same (A, K, Q, J, 10 of same suit)
            // The only way to differentiate is by suit ranking
            return `Both players have Royal Flush, but ${actualWinner.name} wins due to suit ranking.`;
        }
        
        // Function to get detailed hand description for tooltips
        function getDetailedHandDescription(player) {
            if (gameState.currentStage === 'preflop' || gameState.currentStage === 'dealt') {
                // No tooltip before flop is dealt
                return '';
            }
            
            const handRank = getHandRankAtStage([...player.holeCards, ...gameState.communityCards], gameState.currentStage);
            let description = `${handRank.name}`;
            
            // Add specific details for certain hand types
            if (handRank.name === 'High Card') {
                const highCard = getHighCardName([...player.holeCards, ...gameState.communityCards]);
                description += `\n${highCard}`;
            } else if (handRank.name === 'One Pair') {
                const pairValue = findPairValue([...player.holeCards, ...gameState.communityCards]);
                const pairName = getCardName({ value: pairValue, suit: '♠' });
                description += `\nPair of ${pairName}s`;
            } else if (handRank.name === 'Two Pair') {
                description += '\nTwo Pairs';
            } else if (handRank.name === 'Three of a Kind') {
                description += '\nThree Matching Cards';
            } else if (handRank.name === 'Straight') {
                description += '\nFive Consecutive Cards';
            } else if (handRank.name === 'Flush') {
                description += '\nFive Same Suit';
            } else if (handRank.name === 'Full House') {
                description += '\nThree + Two Matching';
            } else if (handRank.name === 'Four of a Kind') {
                description += '\nFour Matching Cards';
            } else if (handRank.name === 'Straight Flush') {
                description += '\nStraight + Same Suit';
            }
            
            return description;
        }
        
        // New function to evaluate hand strength based on current game stage
        function evaluateHandStrengthAtStage(holeCards, communityCards, stage) {
            if (stage === 'preflop' || stage === 'dealt') {
                // Only hole cards are available
                return calculateHoleCardStrength(holeCards);
            } else if (stage === 'flop') {
                // Hole cards + 3 flop cards
                const availableCards = [...holeCards, ...communityCards.slice(0, 3)];
                const handRank = getHandRank(availableCards);
                return handRank.score;
            } else if (stage === 'turn') {
                // Hole cards + 4 community cards
                const availableCards = [...holeCards, ...communityCards.slice(0, 4)];
                const handRank = getHandRank(availableCards);
                return handRank.score;
            } else if (stage === 'river') {
                // Hole cards + all 5 community cards
                const availableCards = [...holeCards, ...communityCards];
                const handRank = getHandRank(availableCards);
                return handRank.score;
            }
            
            // Fallback to full evaluation
            return evaluateHandStrength(holeCards, communityCards);
        }
        
        // New function to get hand rank based on current game stage
        function getHandRankAtStage(cards, stage) {
            if (stage === 'preflop' || stage === 'dealt') {
                // Only hole cards - can only have high card
                const sorted = cards.sort((a, b) => b.value - a.value);
                return { name: 'High Card', score: sorted[0].value };
            } else if (stage === 'flop') {
                // Only first 3 community cards + hole cards
                const availableCards = cards.slice(0, 5); // 2 hole + 3 flop
                return getHandRank(availableCards);
            } else if (stage === 'turn') {
                // First 4 community cards + hole cards
                const availableCards = cards.slice(0, 6); // 2 hole + 4 community
                return getHandRank(availableCards);
            } else if (stage === 'river') {
                // All cards available
                return getHandRank(cards);
            }
            
            // Fallback to full evaluation
            return getHandRank(cards);
        }
        
        // Select winner
        function selectWinner(playerId) {
            // Track winner selection
            trackEvent('select_winner', 'game_action', `player_${playerId + 1}`, gameState.currentStage);
            
            console.log('=== SELECT WINNER DEBUG ===');
            console.log('selectWinner called with playerId:', playerId);
            console.log('Current gameState:', gameState);
            
            gameState.selectedWinner = playerId;
            console.log('Set selectedWinner to:', gameState.selectedWinner);
            
            // Update button states
            const allButtons = document.querySelectorAll('.winner-btn');
            console.log('Found winner buttons:', allButtons.length);
            
            allButtons.forEach(btn => {
                btn.classList.remove('selected');
            });
            
            const selectedButton = document.querySelector(`[data-player="${playerId}"]`);
            console.log('Selected button element:', selectedButton);
            if (selectedButton) {
                selectedButton.classList.add('selected');
                console.log('Added selected class to button');
            } else {
                console.error('Could not find button with data-player:', playerId);
            }
            
            // Automatically evaluate the winner after selection
            console.log('Calling evaluateWinner...');
            try {
                evaluateWinner();
                console.log('evaluateWinner called successfully');
            } catch (error) {
                console.error('Error calling evaluateWinner:', error);
            }
            console.log('=== END SELECT WINNER DEBUG ===');
        }
        
        // Evaluate winner
        function evaluateWinner() {
            console.log('evaluateWinner called, selectedWinner:', gameState.selectedWinner);
            
            if (gameState.selectedWinner === null) {
                console.log('No winner selected, showing error message');
                showMessage('Please select a winner first!', 'error');
                return;
            }
            
            // Find actual winner(s) - handle ties properly
            console.log('Finding winners...');
            let winners = findWinners();
            console.log('Winners found:', winners);
            
            const selectedPlayer = gameState.players[gameState.selectedWinner];
            console.log('Selected player:', selectedPlayer);
            
            // Check if user's prediction was correct
            const isCorrect = winners.some(w => w.id === gameState.selectedWinner);
            console.log('Is correct prediction:', isCorrect);
            
            // Track evaluation
            trackEvent('evaluate_winner', 'game_result', isCorrect ? 'correct' : 'incorrect', gameState.players.length);
            
            // Build the main message
            let mainMessage = '';
            let isTie = winners.length > 1;
            
            if (isTie) {
                // Handle ties - user selected one of the tied players
                const winnerNames = winners.map(w => w.name).join(', ');
                const selectedPlayerName = selectedPlayer.name;
                const isSelectedPlayerInTie = winners.some(w => w.id === gameState.selectedWinner);
                
                if (isSelectedPlayerInTie) {
                    // User correctly selected one of the tied players
                    mainMessage = `🎯 You correctly identified that ${selectedPlayerName} is one of the winners! This is a split between ${winnerNames} with ${getHandRankAtStage([...winners[0].holeCards, ...gameState.communityCards], gameState.currentStage).name}.`;
                } else {
                    // User selected someone not in the tie
                    mainMessage = `❌ ${selectedPlayerName} didn't win. This is a split between ${winnerNames} with ${getHandRankAtStage([...winners[0].holeCards, ...gameState.communityCards], gameState.currentStage).name}.`;
                }
            } else if (isCorrect) {
                // Single winner, user predicted correctly
                mainMessage = `🎉 You correctly predicted that ${selectedPlayer.name} would win!`;
            } else {
                // Single winner, user predicted incorrectly
                const actualPlayer = winners[0];
                mainMessage = `❌ ${actualPlayer.name} actually won with a ${getHandRankAtStage([...actualPlayer.holeCards, ...gameState.communityCards], gameState.currentStage).name}.`;
            }
            
            // Get hand information for explanations
            const selectedHand = getHandRankAtStage([...selectedPlayer.holeCards, ...gameState.communityCards], gameState.currentStage);
            
            // Enhanced explanation for high card wins
            let selectedExplanation = `${selectedPlayer.name} - ${selectedHand.name}`;
            if (selectedHand.name === 'High Card') {
                const selectedHighCard = getHighCardName([...selectedPlayer.holeCards, ...gameState.communityCards]);
                selectedExplanation += ` (${selectedHighCard})`;
            }
            
            let actualExplanation = '';
            if (winners.length === 1) {
                const actualHand = getHandRankAtStage([...winners[0].holeCards, ...gameState.communityCards], gameState.currentStage);
                actualExplanation = `${winners[0].name} - ${actualHand.name}`;
                if (actualHand.name === 'High Card') {
                    const actualHighCard = getHighCardName([...winners[0].holeCards, ...gameState.communityCards]);
                    actualExplanation += ` (${actualHighCard})`;
                }
            } else {
                // Handle ties
                const tieHand = getHandRankAtStage([...winners[0].holeCards, ...gameState.communityCards], gameState.currentStage);
                const winnerNames = winners.map(w => w.name).join(', ');
                actualExplanation = `TIE: ${winnerNames} - ${tieHand.name}`;
                
                if (tieHand.name === 'High Card') {
                    // Show all high cards in the tie
                    const highCards = winners.map(w => {
                        const highCard = getHighCardName([...w.holeCards, ...gameState.communityCards]);
                        return `${w.name}: ${highCard}`;
                    }).join(', ');
                    actualExplanation += ` (${highCards})`;
                }
            }
            
            // Add detailed explanation of why the winner won
            let detailedExplanation = '';
            if (winners.length === 1) {
                if (isCorrect) {
                    // User correctly predicted the winner - explain why they won in detail
                    const winnerHand = getHandRankAtStage([...winners[0].holeCards, ...gameState.communityCards], gameState.currentStage);
                    const otherPlayers = gameState.players.filter(p => p.id !== winners[0].id);
                    
                    // Build detailed explanation of why the winner won
                    let winReasons = [];
                    
                    // Compare with each other player
                    for (let otherPlayer of otherPlayers) {
                        const otherHand = getHandRankAtStage([...otherPlayer.holeCards, ...gameState.communityCards], gameState.currentStage);
                        
                        if (winnerHand.name !== otherHand.name) {
                            // Different hand types - explain the ranking
                            winReasons.push(`${winners[0].name}'s ${winnerHand.name} beats ${otherPlayer.name}'s ${otherHand.name} because ${winnerHand.name} ranks higher than ${otherHand.name} in poker hand rankings.`);
                        } else {
                            // Same hand type - explain why one is better
                            if (winnerHand.name === 'High Card') {
                                winReasons.push(getHighCardComparison(otherPlayer, winners[0]));
                            } else if (winnerHand.name === 'One Pair') {
                                winReasons.push(getOnePairComparison(otherPlayer, winners[0]));
                            } else if (winnerHand.name === 'Two Pair') {
                                winReasons.push(getTwoPairComparison(otherPlayer, winners[0]));
                            } else if (winnerHand.name === 'Three of a Kind') {
                                winReasons.push(getThreeOfAKindComparison(otherPlayer, winners[0]));
                            } else if (winnerHand.name === 'Straight') {
                                winReasons.push(getStraightComparison(otherPlayer, winners[0]));
                            } else if (winnerHand.name === 'Flush') {
                                winReasons.push(getFlushComparison(otherPlayer, winners[0]));
                            } else if (winnerHand.name === 'Full House') {
                                winReasons.push(getFullHouseComparison(otherPlayer, winners[0]));
                            } else if (winnerHand.name === 'Four of a Kind') {
                                winReasons.push(getFourOfAKindComparison(otherPlayer, winners[0]));
                            } else if (winnerHand.name === 'Straight Flush') {
                                winReasons.push(getStraightFlushComparison(otherPlayer, winners[0]));
                            } else if (winnerHand.name === 'Royal Flush') {
                                winReasons.push(getRoyalFlushComparison(otherPlayer, winners[0]));
                            } else {
                                winReasons.push(`Both players have ${winnerHand.name}, but ${winners[0].name} has a stronger version.`);
                            }
                        }
                    }
                    
                    detailedExplanation = `🎯 ${winners[0].name} won with ${winnerHand.name}! Here's why:\n\n${winReasons.join('\n\n')}`;
                } else {
                    // User incorrectly predicted - explain why the selected player lost
                    detailedExplanation = getDetailedWinExplanation(selectedPlayer, winners[0]);
                }
            } else {
                // For ties, explain why they tied
                console.log('=== TIE SCENARIO DEBUG ===');
                console.log('Getting tie explanation for winners:', winners);
                console.log('Winners array length:', winners.length);
                console.log('Winners details:', winners);
                
                try {
                    detailedExplanation = getTieExplanation(winners);
                    console.log('Tie explanation result:', detailedExplanation);
                } catch (error) {
                    console.error('Error getting tie explanation:', error);
                    detailedExplanation = `TIE: ${winners.map(w => w.name).join(', ')} have tied.`;
                }
                console.log('=== END TIE SCENARIO DEBUG ===');
            }
            
            // Build all player hands summary
            let allPlayerHands = '<strong>🃏 All Player Hands:</strong><br>';
            for (let player of gameState.players) {
                const handRank = getHandRankAtStage([...player.holeCards, ...gameState.communityCards], gameState.currentStage);
                let handDescription = `${player.name}: ${handRank.name}`;
                
                // Add specific details for certain hand types
                if (handRank.name === 'High Card') {
                    const highCard = getHighCardName([...player.holeCards, ...gameState.communityCards]);
                    handDescription += ` (${highCard})`;
                } else if (handRank.name === 'One Pair') {
                    const pairValue = findPairValue([...player.holeCards, ...gameState.communityCards]);
                    const pairName = getCardName({ value: pairValue, suit: '♠' });
                    handDescription += ` (${pairName}s)`;
                } else if (handRank.name === 'Two Pair') {
                    const pairValues = Object.entries(getCardCounts([...player.holeCards, ...gameState.communityCards]))
                        .filter(([value, count]) => count === 2)
                        .map(([value, count]) => parseInt(value))
                        .sort((a, b) => b - a);
                    handDescription += ` (${getCardName({ value: pairValues[0], suit: '♠' })}s and ${getCardName({ value: pairValues[1], suit: '♠' })}s)`;
                } else if (handRank.name === 'Three of a Kind') {
                    const counts = getCardCounts([...player.holeCards, ...gameState.communityCards]);
                    const threeValueEntry = Object.entries(counts).find(([value, count]) => count === 3);
                    if (threeValueEntry) {
                        const threeValue = threeValueEntry[0];
                        handDescription += ` (${getCardName({ value: parseInt(threeValue), suit: '♠' })}s)`;
                    } else {
                        handDescription += ` (Three of a Kind)`;
                    }
                } else if (handRank.name === 'Full House') {
                    const counts = getCardCounts([...player.holeCards, ...gameState.communityCards]);
                    const threeValEntry = Object.entries(counts).find(([value, count]) => count === 3);
                    const twoValEntry = Object.entries(counts).find(([value, count]) => count === 2);
                    if (threeValEntry && twoValEntry) {
                        const threeVal = threeValEntry[0];
                        const twoVal = twoValEntry[0];
                        handDescription += ` (${getCardName({ value: parseInt(threeVal), suit: '♠' })}s full of ${getCardName({ value: parseInt(twoVal), suit: '♠' })}s)`;
                    } else {
                        handDescription += ` (Full House)`;
                    }
                } else if (handRank.name === 'Four of a Kind') {
                    const counts = getCardCounts([...player.holeCards, ...gameState.communityCards]);
                    const fourValueEntry = Object.entries(counts).find(([value, count]) => count === 4);
                    if (fourValueEntry) {
                        const fourValue = fourValueEntry[0];
                        handDescription += ` (${getCardName({ value: parseInt(fourValue), suit: '♠' })}s)`;
                    } else {
                        handDescription += ` (Four of a Kind)`;
                    }
                } else if (handRank.name === 'Straight') {
                    const straight = findHighestStraight([...player.holeCards, ...gameState.communityCards]);
                    if (straight && straight.length > 0) {
                        handDescription += ` (${getCardName(straight[0])} high)`;
                    } else {
                        handDescription += ` (Straight)`;
                    }
                } else if (handRank.name === 'Flush') {
                    const suits = {};
                    for (let card of [...player.holeCards, ...gameState.communityCards]) {
                        suits[card.suit] = (suits[card.suit] || 0) + 1;
                    }
                    const flushSuit = Object.entries(suits).find(([suit, count]) => count >= 5)[0];
                    handDescription += ` (${getSuitName(flushSuit)} flush)`;
                }
                
                allPlayerHands += `${handDescription}<br>`;
            }
            
            // Show everything in the unified overlay
            const overlayContent = `
                <h3>${isTie ? (winners.some(w => w.id === gameState.selectedWinner) ? '🎯 Split Detected!' : '🤝 It\'s a Split!') : (isCorrect ? '🎉 Congratulations!' : '❌ Not Right!')}</h3>
                <div class="hand-explanation" style="background: ${isTie ? 'rgba(255, 165, 0, 0.2)' : (isCorrect ? 'rgba(39, 174, 96, 0.2)' : 'rgba(231, 76, 60, 0.2)')}; border: 2px solid ${isTie ? 'rgba(255, 165, 0, 0.5)' : (isCorrect ? 'rgba(39, 174, 96, 0.5)' : 'rgba(231, 76, 60, 0.5)')};">
                    ${mainMessage}
                </div>
                ${detailedExplanation ? `
                    <div class="hand-explanation">
                        <strong>📚 Why this happened:</strong><br>
                        ${detailedExplanation}
                    </div>
                ` : ''}
                <div class="hand-explanation">
                    ${allPlayerHands}
                </div>
            `;
            
            console.log('About to show overlay with content:', overlayContent);
            console.log('isTie:', isTie, 'isCorrect:', isCorrect);
            console.log('Calling showExplanationOverlay...');
            
            try {
                showExplanationOverlay(overlayContent);
                console.log('showExplanationOverlay called successfully');
            } catch (error) {
                console.error('Error calling showExplanationOverlay:', error);
                // Fallback: show message in the message area
                console.log('Falling back to message display');
                showMessage(`Result: ${mainMessage}`, 'info');
            }
            
            // Reset selection
            gameState.selectedWinner = null;
            document.querySelectorAll('.winner-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
        }
        
        // Reset game
        function resetGame() {
            // Track game reset
            trackEvent('reset_game', 'game_action', 'manual_reset', gameState.players.length);
            
            gameState.communityCards = [];
            gameState.currentStage = 'preflop';
            gameState.selectedWinner = null;
            
            // Recreate deck and players with current player count
            createDeck();
            shuffleDeck();
            setupPlayers(); // This will update the player count
            
            updateButtons();
            
            // Clear any messages
            document.getElementById('messageArea').innerHTML = '';
            
            // Clear community cards display
            document.getElementById('communityCards').innerHTML = '';
            
            // Reset explanation overlay
            const overlay = document.getElementById('explanationOverlay');
            if (overlay) {
                overlay.classList.remove('show');
                const contentDiv = document.getElementById('explanationContent');
                if (contentDiv) {
                    contentDiv.innerHTML = '';
                }
                console.log('Reset explanation overlay');
            }
            
            // Reset player displays
            updateDisplay();
        }
        
        // Update display
        function updateDisplay() {
            // Update community cards
            const communityDiv = document.getElementById('communityCards');
            communityDiv.innerHTML = '';
            
            for (let i = 0; i < 5; i++) {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card';
                
                if (i < gameState.communityCards.length) {
                    const card = gameState.communityCards[i];
                    cardDiv.textContent = `${card.rank}${card.suit}`;
                    cardDiv.style.color = (card.suit === '♥' || card.suit === '♦') ? 'red' : 'black';
                    
                    // Add tooltip based on which stage this card was dealt
                    let stageInfo = '';
                    if (i < 3) {
                        stageInfo = 'Flop Card';
                    } else if (i === 3) {
                        stageInfo = 'Turn Card';
                    } else {
                        stageInfo = 'River Card';
                    }
                    cardDiv.title = `${stageInfo}: ${card.rank}${card.suit}`;
                } else {
                    cardDiv.className += ' hidden';
                    let stageInfo = '';
                    if (i === 3) {
                        stageInfo = 'Turn Card (Not Yet Dealt)';
                    } else if (i === 4) {
                        stageInfo = 'River Card (Not Yet Dealt)';
                    }
                    cardDiv.textContent = '';
                    cardDiv.title = stageInfo;
                }
                
                communityDiv.appendChild(cardDiv);
            }
            
            // Update players
            const playersGrid = document.getElementById('playersGrid');
            playersGrid.innerHTML = '';
            
            for (let player of gameState.players) {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player';
                
                let cardsHtml = '';
                if (player.holeCards.length > 0) {
                    // Get detailed hand description for tooltip
                    const handDescription = getDetailedHandDescription(player);
                    
                    for (let card of player.holeCards) {
                        const color = (card.suit === '♥' || card.suit === '♦') ? 'red' : 'black';
                        if (handDescription) {
                            cardsHtml += `<div class="card" style="color: ${color}" title="${handDescription}">${card.rank}${card.suit}</div>`;
                        } else {
                            cardsHtml += `<div class="card" style="color: ${color}">${card.rank}${card.suit}</div>`;
                        }
                    }
                } else {
                    cardsHtml = '<div class="card hidden" title="No cards dealt yet"></div><div class="card hidden" title="No cards dealt yet"></div>';
                }
                
                // Only show probability and winner button if cards are dealt
                let probabilityHtml = '';
                let winnerButtonHtml = '';
                
                if (player.holeCards.length > 0) {
                    probabilityHtml = `<div class="probability">Win Probability: ${player.probability}%</div>`;
                    winnerButtonHtml = `<button class="winner-btn" data-player="${player.id}" onclick="selectWinner(${player.id})">
                        Select as Winner
                    </button>`;
                }
                
                playerDiv.innerHTML = `
                    <h3>${player.name}</h3>
                    <div class="player-cards">${cardsHtml}</div>
                    ${probabilityHtml}
                    ${winnerButtonHtml}
                `;
                
                playersGrid.appendChild(playerDiv);
            }
        }
        
        // Update button states
        function updateButtons() {
            const dealBtn = document.getElementById('dealBtn');
            const flopBtn = document.getElementById('flopBtn');
            const turnBtn = document.getElementById('turnBtn');
            const riverBtn = document.getElementById('riverBtn');
            
            // Reset button is always enabled
            // Reset button doesn't need to be managed here
            
            if (gameState.currentStage === 'preflop') {
                // Initial state or after reset
                dealBtn.disabled = false;
                flopBtn.disabled = true;
                turnBtn.disabled = true;
                riverBtn.disabled = true;
            } else if (gameState.currentStage === 'dealt') {
                // After cards are dealt
                dealBtn.disabled = true;
                flopBtn.disabled = false;
                turnBtn.disabled = true;
                riverBtn.disabled = true;
            } else if (gameState.currentStage === 'flop') {
                // After flop is dealt
                dealBtn.disabled = true;
                flopBtn.disabled = true;
                turnBtn.disabled = false;
                riverBtn.disabled = true;
            } else if (gameState.currentStage === 'turn') {
                // After turn is dealt
                dealBtn.disabled = true;
                flopBtn.disabled = true;
                turnBtn.disabled = true;
                riverBtn.disabled = false;
            } else if (gameState.currentStage === 'river') {
                // After river is dealt
                dealBtn.disabled = true;
                flopBtn.disabled = true;
                turnBtn.disabled = true;
                riverBtn.disabled = true;
            }
        }
        
        // Show message
        function showMessage(text, type) {
            const messageArea = document.getElementById('messageArea');
            messageArea.textContent = text;
            
            // Start the timer
            startMessageTimer();
        }
        
        // Timer variable for message display
        let messageTimer = null;
        
        // Start message timer
        function startMessageTimer() {
            if (messageTimer) {
                clearTimeout(messageTimer);
            }
            messageTimer = setTimeout(() => {
                document.getElementById('messageArea').textContent = '';
            }, 8000);
        }
        
        // Clear message
        function clearMessage() {
            document.getElementById('messageArea').textContent = '';
        }
        
        // Event listeners
        document.getElementById('playerCount').addEventListener('change', function() {
            const newPlayerCount = this.value;
            trackEvent('change_players', 'game_setup', `players_${newPlayerCount}`, parseInt(newPlayerCount));
            resetGame();
        });
        
        // Initialize game
        initGame();
        
        // Instructions toggle function
        function toggleInstructions() {
            const panel = document.getElementById('instructionsPanel');
            const button = document.getElementById('instructionsBtn');
            
            if (panel.style.display === 'none') {
                // Track instructions opened
                trackEvent('open_instructions', 'user_help', 'instructions_panel', 1);
                
                // Show instructions
                panel.style.display = 'block';
                setTimeout(() => {
                    panel.classList.add('show');
                }, 10);
                button.textContent = '📖 Hide Instructions';
            } else {
                // Track instructions closed
                trackEvent('close_instructions', 'user_help', 'instructions_panel', 1);
                
                // Hide instructions
                panel.classList.remove('show');
                setTimeout(() => {
                    panel.style.display = 'none';
                }, 400);
                button.textContent = '📖 How to Play';
            }
        }

    </script>
</body>
</html>